{"ast":null,"code":"/* vim:ts=4:sts=4:sw=4: */\n\n/*!\n *\n * Copyright 2009-2013 Kris Kowal under the terms of the MIT\n * license found at http://github.com/kriskowal/q/raw/master/LICENSE\n *\n * With parts by Tyler Close\n * Copyright 2007-2009 Tyler Close under the terms of the MIT X license found\n * at http://www.opensource.org/licenses/mit-license.html\n * Forked at ref_send.js version: 2009-05-11\n *\n * With parts by Mark Miller\n * Copyright (C) 2011 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\n/*global -WeakMap */\n\"use strict\";\n\nvar hasStacks = false;\n\ntry {\n  throw new Error();\n} catch (e) {\n  hasStacks = !!e.stack;\n} // All code after this point will be filtered from stack traces reported\n// by Q.\n\n\nvar qStartingLine = captureLine();\nvar qFileName;\n\nvar WeakMap = require(\"weak-map\");\n\nvar iterate = require(\"pop-iterate\");\n\nvar asap = require(\"asap\");\n\nfunction isObject(value) {\n  return value === Object(value);\n} // long stack traces\n\n\nvar STACK_JUMP_SEPARATOR = \"From previous event:\";\n\nfunction makeStackTraceLong(error, promise) {\n  // If possible, transform the error stack trace by removing Node and Q\n  // cruft, then concatenating with the stack trace of `promise`. See #57.\n  if (hasStacks && promise.stack && typeof error === \"object\" && error !== null && error.stack && error.stack.indexOf(STACK_JUMP_SEPARATOR) === -1) {\n    var stacks = [];\n\n    for (var p = promise; !!p && handlers.get(p); p = handlers.get(p).became) {\n      if (p.stack) {\n        stacks.unshift(p.stack);\n      }\n    }\n\n    stacks.unshift(error.stack);\n    var concatedStacks = stacks.join(\"\\n\" + STACK_JUMP_SEPARATOR + \"\\n\");\n    error.stack = filterStackString(concatedStacks);\n  }\n}\n\nfunction filterStackString(stackString) {\n  if (Q.isIntrospective) {\n    return stackString;\n  }\n\n  var lines = stackString.split(\"\\n\");\n  var desiredLines = [];\n\n  for (var i = 0; i < lines.length; ++i) {\n    var line = lines[i];\n\n    if (!isInternalFrame(line) && !isNodeFrame(line) && line) {\n      desiredLines.push(line);\n    }\n  }\n\n  return desiredLines.join(\"\\n\");\n}\n\nfunction isNodeFrame(stackLine) {\n  return stackLine.indexOf(\"(module.js:\") !== -1 || stackLine.indexOf(\"(node.js:\") !== -1;\n}\n\nfunction getFileNameAndLineNumber(stackLine) {\n  // Named functions: \"at functionName (filename:lineNumber:columnNumber)\"\n  // In IE10 function name can have spaces (\"Anonymous function\") O_o\n  var attempt1 = /at .+ \\((.+):(\\d+):(?:\\d+)\\)$/.exec(stackLine);\n\n  if (attempt1) {\n    return [attempt1[1], Number(attempt1[2])];\n  } // Anonymous functions: \"at filename:lineNumber:columnNumber\"\n\n\n  var attempt2 = /at ([^ ]+):(\\d+):(?:\\d+)$/.exec(stackLine);\n\n  if (attempt2) {\n    return [attempt2[1], Number(attempt2[2])];\n  } // Firefox style: \"function@filename:lineNumber or @filename:lineNumber\"\n\n\n  var attempt3 = /.*@(.+):(\\d+)$/.exec(stackLine);\n\n  if (attempt3) {\n    return [attempt3[1], Number(attempt3[2])];\n  }\n}\n\nfunction isInternalFrame(stackLine) {\n  var fileNameAndLineNumber = getFileNameAndLineNumber(stackLine);\n\n  if (!fileNameAndLineNumber) {\n    return false;\n  }\n\n  var fileName = fileNameAndLineNumber[0];\n  var lineNumber = fileNameAndLineNumber[1];\n  return fileName === qFileName && lineNumber >= qStartingLine && lineNumber <= qEndingLine;\n} // discover own file name and line number range for filtering stack\n// traces\n\n\nfunction captureLine() {\n  if (!hasStacks) {\n    return;\n  }\n\n  try {\n    throw new Error();\n  } catch (e) {\n    var lines = e.stack.split(\"\\n\");\n    var firstLine = lines[0].indexOf(\"@\") > 0 ? lines[1] : lines[2];\n    var fileNameAndLineNumber = getFileNameAndLineNumber(firstLine);\n\n    if (!fileNameAndLineNumber) {\n      return;\n    }\n\n    qFileName = fileNameAndLineNumber[0];\n    return fileNameAndLineNumber[1];\n  }\n}\n\nfunction deprecate(callback, name, alternative) {\n  return function Q_deprecate() {\n    if (typeof console !== \"undefined\" && typeof console.warn === \"function\") {\n      if (alternative) {\n        console.warn(name + \" is deprecated, use \" + alternative + \" instead.\", new Error(\"\").stack);\n      } else {\n        console.warn(name + \" is deprecated.\", new Error(\"\").stack);\n      }\n    }\n\n    return callback.apply(this, arguments);\n  };\n} // end of long stack traces\n\n\nvar handlers = new WeakMap();\n\nfunction Q_getHandler(promise) {\n  var handler = handlers.get(promise);\n\n  if (!handler || !handler.became) {\n    return handler;\n  }\n\n  handler = follow(handler);\n  handlers.set(promise, handler);\n  return handler;\n}\n\nfunction follow(handler) {\n  if (!handler.became) {\n    return handler;\n  } else {\n    handler.became = follow(handler.became);\n    return handler.became;\n  }\n}\n\nvar theViciousCycleError = new Error(\"Can't resolve a promise with itself\");\nvar theViciousCycleRejection = Q_reject(theViciousCycleError);\nvar theViciousCycle = Q_getHandler(theViciousCycleRejection);\nvar thenables = new WeakMap();\n/**\n * Coerces a value to a promise. If the value is a promise, pass it through\n * unaltered. If the value has a `then` method, it is presumed to be a promise\n * but not one of our own, so it is treated as a “thenable” promise and this\n * returns a promise that stands for it. Otherwise, this returns a promise that\n * has already been fulfilled with the value.\n * @param value promise, object with a then method, or a fulfillment value\n * @returns {Promise} the same promise as given, or a promise for the given\n * value\n */\n\nmodule.exports = Q;\n\nfunction Q(value) {\n  // If the object is already a Promise, return it directly.  This enables\n  // the resolve function to both be used to created references from objects,\n  // but to tolerably coerce non-promises to promises.\n  if (Q_isPromise(value)) {\n    return value;\n  } else if (isThenable(value)) {\n    if (!thenables.has(value)) {\n      thenables.set(value, new Promise(new Thenable(value)));\n    }\n\n    return thenables.get(value);\n  } else {\n    return new Promise(new Fulfilled(value));\n  }\n}\n/**\n * Controls whether or not long stack traces will be on\n * @type {boolean}\n */\n\n\nQ.longStackSupport = false;\n/**\n * Returns a promise that has been rejected with a reason, which should be an\n * instance of `Error`.\n * @param {Error} error reason for the failure.\n * @returns {Promise} rejection\n */\n\nQ.reject = Q_reject;\n\nfunction Q_reject(error) {\n  return new Promise(new Rejected(error));\n}\n/**\n * Constructs a {promise, resolve, reject} object.\n *\n * `resolve` is a callback to invoke with a more resolved value for the\n * promise. To fulfill the promise, invoke `resolve` with any value that is\n * not a thenable. To reject the promise, invoke `resolve` with a rejected\n * thenable, or invoke `reject` with the reason directly. To resolve the\n * promise to another thenable, thus putting it in the same state, invoke\n * `resolve` with that other thenable.\n *\n * @returns {{promise, resolve, reject}} a deferred\n */\n\n\nQ.defer = defer;\n\nfunction defer() {\n  var handler = new Pending();\n  var promise = new Promise(handler);\n  var deferred = new Deferred(promise);\n\n  if (Q.longStackSupport && hasStacks) {\n    try {\n      throw new Error();\n    } catch (e) {\n      // NOTE: don't try to use `Error.captureStackTrace` or transfer the\n      // accessor around; that causes memory leaks as per GH-111. Just\n      // reify the stack trace as a string ASAP.\n      //\n      // At the same time, cut off the first line; it's always just\n      // \"[object Promise]\\n\", as per the `toString`.\n      promise.stack = e.stack.substring(e.stack.indexOf(\"\\n\") + 1);\n    }\n  }\n\n  return deferred;\n} // TODO\n\n/**\n */\n\n\nQ.when = function Q_when(value, fulfilled, rejected, ms) {\n  return Q(value).then(fulfilled, rejected, ms);\n};\n/**\n * Turns an array of promises into a promise for an array.  If any of the\n * promises gets rejected, the whole array is rejected immediately.\n * @param {Array.<Promise>} an array (or promise for an array) of values (or\n * promises for values)\n * @returns {Promise.<Array>} a promise for an array of the corresponding values\n */\n// By Mark Miller\n// http://wiki.ecmascript.org/doku.php?id=strawman:concurrency&rev=1308776521#allfulfilled\n\n\nQ.all = Q_all;\n\nfunction Q_all(questions) {\n  // XXX deprecated behavior\n  if (Q_isPromise(questions)) {\n    if (typeof console !== \"undefined\" && typeof console.warn === \"function\") {\n      console.warn(\"Q.all no longer directly unwraps a promise. Use Q(array).all()\");\n    }\n\n    return Q(questions).all();\n  }\n\n  var countDown = 0;\n  var deferred = defer();\n  var answers = Array(questions.length);\n  var estimates = [];\n  var estimate = -Infinity;\n  var setEstimate;\n  Array.prototype.forEach.call(questions, function Q_all_each(promise, index) {\n    var handler;\n\n    if (Q_isPromise(promise) && (handler = Q_getHandler(promise)).state === \"fulfilled\") {\n      answers[index] = handler.value;\n    } else {\n      ++countDown;\n      promise = Q(promise);\n      promise.then(function Q_all_eachFulfilled(value) {\n        answers[index] = value;\n\n        if (--countDown === 0) {\n          deferred.resolve(answers);\n        }\n      }, deferred.reject);\n      promise.observeEstimate(function Q_all_eachEstimate(newEstimate) {\n        var oldEstimate = estimates[index];\n        estimates[index] = newEstimate;\n\n        if (newEstimate > estimate) {\n          estimate = newEstimate;\n        } else if (oldEstimate === estimate && newEstimate <= estimate) {\n          // There is a 1/length chance that we will need to perform\n          // this O(length) walk, so amortized O(1)\n          computeEstimate();\n        }\n\n        if (estimates.length === questions.length && estimate !== setEstimate) {\n          deferred.setEstimate(estimate);\n          setEstimate = estimate;\n        }\n      });\n    }\n  });\n\n  function computeEstimate() {\n    estimate = -Infinity;\n\n    for (var index = 0; index < estimates.length; index++) {\n      if (estimates[index] > estimate) {\n        estimate = estimates[index];\n      }\n    }\n  }\n\n  if (countDown === 0) {\n    deferred.resolve(answers);\n  }\n\n  return deferred.promise;\n}\n/**\n * @see Promise#allSettled\n */\n\n\nQ.allSettled = Q_allSettled;\n\nfunction Q_allSettled(questions) {\n  // XXX deprecated behavior\n  if (Q_isPromise(questions)) {\n    if (typeof console !== \"undefined\" && typeof console.warn === \"function\") {\n      console.warn(\"Q.allSettled no longer directly unwraps a promise. Use Q(array).allSettled()\");\n    }\n\n    return Q(questions).allSettled();\n  }\n\n  return Q_all(questions.map(function Q_allSettled_each(promise) {\n    promise = Q(promise);\n\n    function regardless() {\n      return promise.inspect();\n    }\n\n    return promise.then(regardless, regardless);\n  }));\n}\n/**\n * Returns a promise for the given value (or promised value), some\n * milliseconds after it resolved. Passes rejections immediately.\n * @param {Any*} promise\n * @param {Number} milliseconds\n * @returns a promise for the resolution of the given promise after milliseconds\n * time has elapsed since the resolution of the given promise.\n * If the given promise rejects, that is passed immediately.\n */\n\n\nQ.delay = function Q_delay(object, timeout) {\n  if (timeout === void 0) {\n    timeout = object;\n    object = void 0;\n  }\n\n  return Q(object).delay(timeout);\n};\n/**\n * Causes a promise to be rejected if it does not get fulfilled before\n * some milliseconds time out.\n * @param {Any*} promise\n * @param {Number} milliseconds timeout\n * @param {String} custom error message (optional)\n * @returns a promise for the resolution of the given promise if it is\n * fulfilled before the timeout, otherwise rejected.\n */\n\n\nQ.timeout = function Q_timeout(object, ms, message) {\n  return Q(object).timeout(ms, message);\n};\n/**\n * Spreads the values of a promised array of arguments into the\n * fulfillment callback.\n * @param fulfilled callback that receives variadic arguments from the\n * promised array\n * @param rejected callback that receives the exception if the promise\n * is rejected.\n * @returns a promise for the return value or thrown exception of\n * either callback.\n */\n\n\nQ.spread = Q_spread;\n\nfunction Q_spread(value, fulfilled, rejected) {\n  return Q(value).spread(fulfilled, rejected);\n}\n/**\n * If two promises eventually fulfill to the same value, promises that value,\n * but otherwise rejects.\n * @param x {Any*}\n * @param y {Any*}\n * @returns {Any*} a promise for x and y if they are the same, but a rejection\n * otherwise.\n *\n */\n\n\nQ.join = function Q_join(x, y) {\n  return Q.spread([x, y], function Q_joined(x, y) {\n    if (x === y) {\n      // TODO: \"===\" should be Object.is or equiv\n      return x;\n    } else {\n      throw new Error(\"Can't join: not the same: \" + x + \" \" + y);\n    }\n  });\n};\n/**\n * Returns a promise for the first of an array of promises to become fulfilled.\n * @param answers {Array} promises to race\n * @returns {Promise} the first promise to be fulfilled\n */\n\n\nQ.race = Q_race;\n\nfunction Q_race(answerPs) {\n  return new Promise(function (deferred) {\n    answerPs.forEach(function (answerP) {\n      Q(answerP).then(deferred.resolve, deferred.reject);\n    });\n  });\n}\n/**\n * Calls the promised function in a future turn.\n * @param object    promise or immediate reference for target function\n * @param ...args   array of application arguments\n */\n\n\nQ.try = function Q_try(callback) {\n  return Q(callback).dispatch(\"call\", [[]]);\n};\n/**\n * TODO\n */\n\n\nQ.function = Promise_function;\n\nfunction Promise_function(wrapped) {\n  return function promiseFunctionWrapper() {\n    var args = new Array(arguments.length);\n\n    for (var index = 0; index < arguments.length; index++) {\n      args[index] = arguments[index];\n    }\n\n    return Q(wrapped).apply(this, args);\n  };\n}\n/**\n * The promised function decorator ensures that any promise arguments\n * are settled and passed as values (`this` is also settled and passed\n * as a value).  It will also ensure that the result of a function is\n * always a promise.\n *\n * @example\n * var add = Q.promised(function (a, b) {\n *     return a + b;\n * });\n * add(Q(a), Q(B));\n *\n * @param {function} callback The function to decorate\n * @returns {function} a function that has been decorated.\n */\n\n\nQ.promised = function Q_promised(callback) {\n  return function promisedMethod() {\n    var args = new Array(arguments.length);\n\n    for (var index = 0; index < arguments.length; index++) {\n      args[index] = arguments[index];\n    }\n\n    return Q_spread([this, Q_all(args)], function Q_promised_spread(self, args) {\n      return callback.apply(self, args);\n    });\n  };\n};\n/**\n */\n\n\nQ.passByCopy = // TODO XXX experimental\nQ.push = function (value) {\n  if (Object(value) === value && !Q_isPromise(value)) {\n    passByCopies.set(value, true);\n  }\n\n  return value;\n};\n\nQ.isPortable = function (value) {\n  return Object(value) === value && passByCopies.has(value);\n};\n\nvar passByCopies = new WeakMap();\n/**\n * The async function is a decorator for generator functions, turning\n * them into asynchronous generators. Although generators are only\n * part of the newest ECMAScript 6 drafts, this code does not cause\n * syntax errors in older engines. This code should continue to work\n * and will in fact improve over time as the language improves.\n *\n * ES6 generators are currently part of V8 version 3.19 with the\n * `--harmony-generators` runtime flag enabled. This function does not\n * support the former, Pythonic generators that were only implemented\n * by SpiderMonkey.\n *\n * Decorates a generator function such that:\n *  - it may yield promises\n *  - execution will continue when that promise is fulfilled\n *  - the value of the yield expression will be the fulfilled value\n *  - it returns a promise for the return value (when the generator\n *    stops iterating)\n *  - the decorated function returns a promise for the return value\n *    of the generator or the first rejected promise among those\n *    yielded.\n *  - if an error is thrown in the generator, it propagates through\n *    every following yield until it is caught, or until it escapes\n *    the generator function altogether, and is translated into a\n *    rejection for the promise returned by the decorated generator.\n */\n\nQ.async = Q_async;\n\nfunction Q_async(makeGenerator) {\n  return function spawn() {\n    // when verb is \"send\", arg is a value\n    // when verb is \"throw\", arg is an exception\n    function continuer(verb, arg) {\n      var iteration;\n\n      try {\n        iteration = generator[verb](arg);\n      } catch (exception) {\n        return Q_reject(exception);\n      }\n\n      if (iteration.done) {\n        return Q(iteration.value);\n      } else {\n        return Q(iteration.value).then(callback, errback);\n      }\n    }\n\n    var generator = makeGenerator.apply(this, arguments);\n    var callback = continuer.bind(continuer, \"next\");\n    var errback = continuer.bind(continuer, \"throw\");\n    return callback();\n  };\n}\n/**\n * The spawn function is a small wrapper around async that immediately\n * calls the generator and also ends the promise chain, so that any\n * unhandled errors are thrown instead of forwarded to the error\n * handler. This is useful because it's extremely common to run\n * generators at the top-level to work with libraries.\n */\n\n\nQ.spawn = Q_spawn;\n\nfunction Q_spawn(makeGenerator) {\n  Q_async(makeGenerator)().done();\n} // Thus begins the section dedicated to the Promise\n\n/**\n * TODO\n */\n\n\nQ.Promise = Promise;\n\nfunction Promise(handler) {\n  if (!(this instanceof Promise)) {\n    return new Promise(handler);\n  }\n\n  if (typeof handler === \"function\") {\n    var setup = handler;\n    var deferred = defer();\n    handler = Q_getHandler(deferred.promise);\n\n    try {\n      setup(deferred.resolve, deferred.reject, deferred.setEstimate);\n    } catch (error) {\n      deferred.reject(error);\n    }\n  }\n\n  handlers.set(this, handler);\n}\n/**\n * Turns an array of promises into a promise for an array.  If any of the\n * promises gets rejected, the whole array is rejected immediately.\n * @param {Array.<Promise>} an array (or promise for an array) of values (or\n * promises for values)\n * @returns {Promise.<Array>} a promise for an array of the corresponding values\n */\n\n\nPromise.all = Q_all;\n/**\n * Returns a promise for the first of an array of promises to become fulfilled.\n * @param answers {Array} promises to race\n * @returns {Promise} the first promise to be fulfilled\n */\n\nPromise.race = Q_race;\n/**\n * Coerces a value to a promise. If the value is a promise, pass it through\n * unaltered. If the value has a `then` method, it is presumed to be a promise\n * but not one of our own, so it is treated as a “thenable” promise and this\n * returns a promise that stands for it. Otherwise, this returns a promise that\n * has already been fulfilled with the value.\n * @param value promise, object with a then method, or a fulfillment value\n * @returns {Promise} the same promise as given, or a promise for the given\n * value\n */\n\nPromise.resolve = Promise_resolve;\n\nfunction Promise_resolve(value) {\n  return Q(value);\n}\n/**\n * Returns a promise that has been rejected with a reason, which should be an\n * instance of `Error`.\n * @param reason value describing the failure\n * @returns {Promise} rejection\n */\n\n\nPromise.reject = Q_reject;\n/**\n * @returns {boolean} whether the given value is a promise.\n */\n\nQ.isPromise = Q_isPromise;\n\nfunction Q_isPromise(object) {\n  return isObject(object) && !!handlers.get(object);\n}\n/**\n * @returns {boolean} whether the given value is an object with a then method.\n * @private\n */\n\n\nfunction isThenable(object) {\n  return isObject(object) && typeof object.then === \"function\";\n}\n/**\n * Synchronously produces a snapshot of the internal state of the promise.  The\n * object will have a `state` property. If the `state` is `\"pending\"`, there\n * will be no further information. If the `state` is `\"fulfilled\"`, there will\n * be a `value` property. If the state is `\"rejected\"` there will be a `reason`\n * property.  If the promise was constructed from a “thenable” and `then` nor\n * any other method has been dispatched on the promise has been called, the\n * state will be `\"pending\"`. The state object will not be updated if the\n * state changes and changing it will have no effect on the promise. Every\n * call to `inspect` produces a unique object.\n * @returns {{state: string, value?, reason?}}\n */\n\n\nPromise.prototype.inspect = function Promise_inspect() {\n  // the second layer captures only the relevant \"state\" properties of the\n  // handler to prevent leaking the capability to access or alter the\n  // handler.\n  return Q_getHandler(this).inspect();\n};\n/**\n * @returns {boolean} whether the promise is waiting for a result.\n */\n\n\nPromise.prototype.isPending = function Promise_isPending() {\n  return Q_getHandler(this).state === \"pending\";\n};\n/**\n * @returns {boolean} whether the promise has ended in a result and has a\n * fulfillment value.\n */\n\n\nPromise.prototype.isFulfilled = function Promise_isFulfilled() {\n  return Q_getHandler(this).state === \"fulfilled\";\n};\n/**\n * @returns {boolean} whether the promise has ended poorly and has a reason for\n * its rejection.\n */\n\n\nPromise.prototype.isRejected = function Promise_isRejected() {\n  return Q_getHandler(this).state === \"rejected\";\n};\n/**\n * TODO\n */\n\n\nPromise.prototype.toBePassed = function Promise_toBePassed() {\n  return Q_getHandler(this).state === \"passed\";\n};\n/**\n * @returns {string} merely `\"[object Promise]\"`\n */\n\n\nPromise.prototype.toString = function Promise_toString() {\n  return \"[object Promise]\";\n};\n/**\n * Creates a new promise, waits for this promise to be resolved, and informs\n * either the fullfilled or rejected handler of the result. Whatever result\n * comes of the fulfilled or rejected handler, a value returned, a promise\n * returned, or an error thrown, becomes the resolution for the promise\n * returned by `then`.\n *\n * @param fulfilled\n * @param rejected\n * @returns {Promise} for the result of `fulfilled` or `rejected`.\n */\n\n\nPromise.prototype.then = function Promise_then(fulfilled, rejected, ms) {\n  var self = this;\n  var deferred = defer();\n\n  var _fulfilled;\n\n  if (typeof fulfilled === \"function\") {\n    _fulfilled = function Promise_then_fulfilled(value) {\n      try {\n        deferred.resolve(fulfilled.call(void 0, value));\n      } catch (error) {\n        deferred.reject(error);\n      }\n    };\n  } else {\n    _fulfilled = deferred.resolve;\n  }\n\n  var _rejected;\n\n  if (typeof rejected === \"function\") {\n    _rejected = function Promise_then_rejected(error) {\n      try {\n        deferred.resolve(rejected.call(void 0, error));\n      } catch (newError) {\n        deferred.reject(newError);\n      }\n    };\n  } else {\n    _rejected = deferred.reject;\n  }\n\n  this.done(_fulfilled, _rejected);\n\n  if (ms !== void 0) {\n    var updateEstimate = function Promise_then_updateEstimate() {\n      deferred.setEstimate(self.getEstimate() + ms);\n    };\n\n    this.observeEstimate(updateEstimate);\n    updateEstimate();\n  }\n\n  return deferred.promise;\n};\n/**\n * Terminates a chain of promises, forcing rejections to be\n * thrown as exceptions.\n * @param fulfilled\n * @param rejected\n */\n\n\nPromise.prototype.done = function Promise_done(fulfilled, rejected) {\n  var self = this;\n  var done = false; // ensure the untrusted promise makes at most a\n  // single call to one of the callbacks\n\n  asap(function Promise_done_task() {\n    var _fulfilled;\n\n    if (typeof fulfilled === \"function\") {\n      if (Q.onerror) {\n        _fulfilled = function Promise_done_fulfilled(value) {\n          if (done) {\n            return;\n          }\n\n          done = true;\n\n          try {\n            fulfilled.call(void 0, value);\n          } catch (error) {\n            // fallback to rethrow is still necessary because\n            // _fulfilled is not called in the same event as the\n            // above guard.\n            (Q.onerror || Promise_rethrow)(error);\n          }\n        };\n      } else {\n        _fulfilled = function Promise_done_fulfilled(value) {\n          if (done) {\n            return;\n          }\n\n          done = true;\n          fulfilled.call(void 0, value);\n        };\n      }\n    }\n\n    var _rejected;\n\n    if (typeof rejected === \"function\" && Q.onerror) {\n      _rejected = function Promise_done_rejected(error) {\n        if (done) {\n          return;\n        }\n\n        done = true;\n        makeStackTraceLong(error, self);\n\n        try {\n          rejected.call(void 0, error);\n        } catch (newError) {\n          (Q.onerror || Promise_rethrow)(newError);\n        }\n      };\n    } else if (typeof rejected === \"function\") {\n      _rejected = function Promise_done_rejected(error) {\n        if (done) {\n          return;\n        }\n\n        done = true;\n        makeStackTraceLong(error, self);\n        rejected.call(void 0, error);\n      };\n    } else {\n      _rejected = Q.onerror || Promise_rethrow;\n    }\n\n    if (typeof process === \"object\" && process.domain) {\n      _rejected = process.domain.bind(_rejected);\n    }\n\n    Q_getHandler(self).dispatch(_fulfilled, \"then\", [_rejected]);\n  });\n};\n\nfunction Promise_rethrow(error) {\n  throw error;\n}\n/**\n * TODO\n */\n\n\nPromise.prototype.thenResolve = function Promise_thenResolve(value) {\n  // Wrapping ahead of time to forestall multiple wrappers.\n  value = Q(value); // Using all is necessary to aggregate the estimated time to completion.\n\n  return Q_all([this, value]).then(function Promise_thenResolve_resolved() {\n    return value;\n  }, null, 0); // 0: does not contribute significantly to the estimated time to\n  // completion.\n};\n/**\n * TODO\n */\n\n\nPromise.prototype.thenReject = function Promise_thenReject(error) {\n  return this.then(function Promise_thenReject_resolved() {\n    throw error;\n  }, null, 0); // 0: does not contribute significantly to the estimated time to\n  // completion.\n};\n/**\n * TODO\n */\n\n\nPromise.prototype.all = function Promise_all() {\n  return this.then(Q_all);\n};\n/**\n * Turns an array of promises into a promise for an array of their states (as\n * returned by `inspect`) when they have all settled.\n * @param {Array[Any*]} values an array (or promise for an array) of values (or\n * promises for values)\n * @returns {Array[State]} an array of states for the respective values.\n */\n\n\nPromise.prototype.allSettled = function Promise_allSettled() {\n  return this.then(Q_allSettled);\n};\n/**\n * TODO\n */\n\n\nPromise.prototype.catch = function Promise_catch(rejected) {\n  return this.then(void 0, rejected);\n};\n/**\n * TODO\n */\n\n\nPromise.prototype.finally = function Promise_finally(callback, ms) {\n  if (!callback) {\n    return this;\n  }\n\n  callback = Q(callback);\n  return this.then(function (value) {\n    return callback.call().then(function Promise_finally_fulfilled() {\n      return value;\n    });\n  }, function (reason) {\n    // TODO attempt to recycle the rejection with \"this\".\n    return callback.call().then(function Promise_finally_rejected() {\n      throw reason;\n    });\n  }, ms);\n};\n/**\n * TODO\n */\n\n\nPromise.prototype.observeEstimate = function Promise_observeEstimate(emit) {\n  this.rawDispatch(null, \"estimate\", [emit]);\n  return this;\n};\n/**\n * TODO\n */\n\n\nPromise.prototype.getEstimate = function Promise_getEstimate() {\n  return Q_getHandler(this).estimate;\n};\n/**\n * TODO\n */\n\n\nPromise.prototype.dispatch = function Promise_dispatch(op, args) {\n  var deferred = defer();\n  this.rawDispatch(deferred.resolve, op, args);\n  return deferred.promise;\n};\n/**\n */\n\n\nPromise.prototype.rawDispatch = function Promise_rawDispatch(resolve, op, args) {\n  var self = this;\n  asap(function Promise_dispatch_task() {\n    Q_getHandler(self).dispatch(resolve, op, args);\n  });\n};\n/**\n * TODO\n */\n\n\nPromise.prototype.get = function Promise_get(name) {\n  return this.dispatch(\"get\", [name]);\n};\n/**\n * TODO\n */\n\n\nPromise.prototype.invoke = function Promise_invoke(name\n/*...args*/\n) {\n  var args = new Array(arguments.length - 1);\n\n  for (var index = 1; index < arguments.length; index++) {\n    args[index - 1] = arguments[index];\n  }\n\n  return this.dispatch(\"invoke\", [name, args]);\n};\n/**\n * TODO\n */\n\n\nPromise.prototype.apply = function Promise_apply(thisp, args) {\n  return this.dispatch(\"call\", [args, thisp]);\n};\n/**\n * TODO\n */\n\n\nPromise.prototype.call = function Promise_call(thisp\n/*, ...args*/\n) {\n  var args = new Array(Math.max(0, arguments.length - 1));\n\n  for (var index = 1; index < arguments.length; index++) {\n    args[index - 1] = arguments[index];\n  }\n\n  return this.dispatch(\"call\", [args, thisp]);\n};\n/**\n * TODO\n */\n\n\nPromise.prototype.bind = function Promise_bind(thisp\n/*, ...args*/\n) {\n  var self = this;\n  var args = new Array(Math.max(0, arguments.length - 1));\n\n  for (var index = 1; index < arguments.length; index++) {\n    args[index - 1] = arguments[index];\n  }\n\n  return function\n    /*...args*/\n  Promise_bind_bound() {\n    var boundArgs = args.slice();\n\n    for (var index = 0; index < arguments.length; index++) {\n      boundArgs[boundArgs.length] = arguments[index];\n    }\n\n    return self.dispatch(\"call\", [boundArgs, thisp]);\n  };\n};\n/**\n * TODO\n */\n\n\nPromise.prototype.keys = function Promise_keys() {\n  return this.dispatch(\"keys\", []);\n};\n/**\n * TODO\n */\n\n\nPromise.prototype.iterate = function Promise_iterate() {\n  return this.dispatch(\"iterate\", []);\n};\n/**\n * TODO\n */\n\n\nPromise.prototype.spread = function Promise_spread(fulfilled, rejected, ms) {\n  return this.all().then(function Promise_spread_fulfilled(array) {\n    return fulfilled.apply(void 0, array);\n  }, rejected, ms);\n};\n/**\n * Causes a promise to be rejected if it does not get fulfilled before\n * some milliseconds time out.\n * @param {Number} milliseconds timeout\n * @param {String} custom error message (optional)\n * @returns a promise for the resolution of the given promise if it is\n * fulfilled before the timeout, otherwise rejected.\n */\n\n\nPromise.prototype.timeout = function Promsie_timeout(ms, message) {\n  var deferred = defer();\n  var timeoutId = setTimeout(function Promise_timeout_task() {\n    deferred.reject(new Error(message || \"Timed out after \" + ms + \" ms\"));\n  }, ms);\n  this.then(function Promise_timeout_fulfilled(value) {\n    clearTimeout(timeoutId);\n    deferred.resolve(value);\n  }, function Promise_timeout_rejected(error) {\n    clearTimeout(timeoutId);\n    deferred.reject(error);\n  });\n  return deferred.promise;\n};\n/**\n * Returns a promise for the given value (or promised value), some\n * milliseconds after it resolved. Passes rejections immediately.\n * @param {Any*} promise\n * @param {Number} milliseconds\n * @returns a promise for the resolution of the given promise after milliseconds\n * time has elapsed since the resolution of the given promise.\n * If the given promise rejects, that is passed immediately.\n */\n\n\nPromise.prototype.delay = function Promise_delay(ms) {\n  return this.then(function Promise_delay_fulfilled(value) {\n    var deferred = defer();\n    deferred.setEstimate(Date.now() + ms);\n    setTimeout(function Promise_delay_task() {\n      deferred.resolve(value);\n    }, ms);\n    return deferred.promise;\n  }, null, ms);\n};\n/**\n * TODO\n */\n\n\nPromise.prototype.pull = function Promise_pull() {\n  return this.dispatch(\"pull\", []);\n};\n/**\n * TODO\n */\n\n\nPromise.prototype.pass = function Promise_pass() {\n  if (!this.toBePassed()) {\n    return new Promise(new Passed(this));\n  } else {\n    return this;\n  }\n}; // Thus begins the portion dedicated to the deferred\n\n\nvar promises = new WeakMap();\n\nfunction Deferred(promise) {\n  this.promise = promise; // A deferred has an intrinsic promise, denoted by its hidden handler\n  // property.  The promise property of the deferred may be assigned to a\n  // different promise (as it is in a Queue), but the intrinsic promise does\n  // not change.\n\n  promises.set(this, promise);\n  var self = this;\n  var resolve = this.resolve;\n\n  this.resolve = function (value) {\n    resolve.call(self, value);\n  };\n\n  var reject = this.reject;\n\n  this.reject = function (error) {\n    reject.call(self, error);\n  };\n}\n/**\n * TODO\n */\n\n\nDeferred.prototype.resolve = function Deferred_resolve(value) {\n  var handler = Q_getHandler(promises.get(this));\n\n  if (!handler.messages) {\n    return;\n  }\n\n  handler.become(Q(value));\n};\n/**\n * TODO\n */\n\n\nDeferred.prototype.reject = function Deferred_reject(reason) {\n  var handler = Q_getHandler(promises.get(this));\n\n  if (!handler.messages) {\n    return;\n  }\n\n  handler.become(Q_reject(reason));\n};\n/**\n * TODO\n */\n\n\nDeferred.prototype.setEstimate = function Deferred_setEstimate(estimate) {\n  estimate = +estimate;\n\n  if (estimate !== estimate) {\n    estimate = Infinity;\n  }\n\n  if (estimate < 1e12 && estimate !== -Infinity) {\n    throw new Error(\"Estimate values should be a number of miliseconds in the future\");\n  }\n\n  var handler = Q_getHandler(promises.get(this)); // TODO There is a bit of capability leakage going on here. The Deferred\n  // should only be able to set the estimate for its original\n  // Pending, not for any handler that promise subsequently became.\n\n  if (handler.setEstimate) {\n    handler.setEstimate(estimate);\n  }\n}; // Thus ends the public interface\n// Thus begins the portion dedicated to handlers\n\n\nfunction Fulfilled(value) {\n  this.value = value;\n  this.estimate = Date.now();\n}\n\nFulfilled.prototype.state = \"fulfilled\";\n\nFulfilled.prototype.inspect = function Fulfilled_inspect() {\n  return {\n    state: \"fulfilled\",\n    value: this.value\n  };\n};\n\nFulfilled.prototype.dispatch = function Fulfilled_dispatch(resolve, op, operands) {\n  var result;\n\n  if (op === \"then\" || op === \"get\" || op === \"call\" || op === \"invoke\" || op === \"keys\" || op === \"iterate\" || op === \"pull\") {\n    try {\n      result = this[op].apply(this, operands);\n    } catch (exception) {\n      result = Q_reject(exception);\n    }\n  } else if (op === \"estimate\") {\n    operands[0].call(void 0, this.estimate);\n  } else {\n    var error = new Error(\"Fulfilled promises do not support the \" + op + \" operator\");\n    result = Q_reject(error);\n  }\n\n  if (resolve) {\n    resolve(result);\n  }\n};\n\nFulfilled.prototype.then = function Fulfilled_then() {\n  return this.value;\n};\n\nFulfilled.prototype.get = function Fulfilled_get(name) {\n  return this.value[name];\n};\n\nFulfilled.prototype.call = function Fulfilled_call(args, thisp) {\n  return this.callInvoke(this.value, args, thisp);\n};\n\nFulfilled.prototype.invoke = function Fulfilled_invoke(name, args) {\n  return this.callInvoke(this.value[name], args, this.value);\n};\n\nFulfilled.prototype.callInvoke = function Fulfilled_callInvoke(callback, args, thisp) {\n  var waitToBePassed;\n\n  for (var index = 0; index < args.length; index++) {\n    if (Q_isPromise(args[index]) && args[index].toBePassed()) {\n      waitToBePassed = waitToBePassed || [];\n      waitToBePassed.push(args[index]);\n    }\n  }\n\n  if (waitToBePassed) {\n    var self = this;\n    return Q_all(waitToBePassed).then(function () {\n      return self.callInvoke(callback, args.map(function (arg) {\n        if (Q_isPromise(arg) && arg.toBePassed()) {\n          return arg.inspect().value;\n        } else {\n          return arg;\n        }\n      }), thisp);\n    });\n  } else {\n    return callback.apply(thisp, args);\n  }\n};\n\nFulfilled.prototype.keys = function Fulfilled_keys() {\n  return Object.keys(this.value);\n};\n\nFulfilled.prototype.iterate = function Fulfilled_iterate() {\n  return iterate(this.value);\n};\n\nFulfilled.prototype.pull = function Fulfilled_pull() {\n  var result;\n\n  if (Object(this.value) === this.value) {\n    result = Array.isArray(this.value) ? [] : {};\n\n    for (var name in this.value) {\n      result[name] = this.value[name];\n    }\n  } else {\n    result = this.value;\n  }\n\n  return Q.push(result);\n};\n\nfunction Rejected(reason) {\n  this.reason = reason;\n  this.estimate = Infinity;\n}\n\nRejected.prototype.state = \"rejected\";\n\nRejected.prototype.inspect = function Rejected_inspect() {\n  return {\n    state: \"rejected\",\n    reason: this.reason\n  };\n};\n\nRejected.prototype.dispatch = function Rejected_dispatch(resolve, op, operands) {\n  var result;\n\n  if (op === \"then\") {\n    result = this.then(resolve, operands[0]);\n  } else {\n    result = this;\n  }\n\n  if (resolve) {\n    resolve(result);\n  }\n};\n\nRejected.prototype.then = function Rejected_then(resolve, rejected) {\n  return rejected ? rejected(this.reason) : this;\n};\n\nfunction Pending() {\n  // if \"messages\" is an \"Array\", that indicates that the promise has not yet\n  // been resolved.  If it is \"undefined\", it has been resolved.  Each\n  // element of the messages array is itself an array of complete arguments to\n  // forward to the resolved promise.  We coerce the resolution value to a\n  // promise using the `resolve` function because it handles both fully\n  // non-thenable values and other thenables gracefully.\n  this.messages = [];\n  this.observers = [];\n  this.estimate = Infinity;\n}\n\nPending.prototype.state = \"pending\";\n\nPending.prototype.inspect = function Pending_inspect() {\n  return {\n    state: \"pending\"\n  };\n};\n\nPending.prototype.dispatch = function Pending_dispatch(resolve, op, operands) {\n  this.messages.push([resolve, op, operands]);\n\n  if (op === \"estimate\") {\n    this.observers.push(operands[0]);\n    var self = this;\n    asap(function Pending_dispatch_task() {\n      operands[0].call(void 0, self.estimate);\n    });\n  }\n};\n\nPending.prototype.become = function Pending_become(promise) {\n  this.became = theViciousCycle;\n  var handler = Q_getHandler(promise);\n  this.became = handler;\n  handlers.set(promise, handler);\n  this.promise = void 0;\n  this.messages.forEach(function Pending_become_eachMessage(message) {\n    // makeQ does not have this asap call, so it must be queueing events\n    // downstream. TODO look at makeQ to ascertain\n    asap(function Pending_become_eachMessage_task() {\n      var handler = Q_getHandler(promise);\n      handler.dispatch.apply(handler, message);\n    });\n  });\n  this.messages = void 0;\n  this.observers = void 0;\n};\n\nPending.prototype.setEstimate = function Pending_setEstimate(estimate) {\n  if (this.observers) {\n    var self = this;\n    self.estimate = estimate;\n    this.observers.forEach(function Pending_eachObserver(observer) {\n      asap(function Pending_setEstimate_eachObserver_task() {\n        observer.call(void 0, estimate);\n      });\n    });\n  }\n};\n\nfunction Thenable(thenable) {\n  this.thenable = thenable;\n  this.became = null;\n  this.estimate = Infinity;\n}\n\nThenable.prototype.state = \"thenable\";\n\nThenable.prototype.inspect = function Thenable_inspect() {\n  return {\n    state: \"pending\"\n  };\n};\n\nThenable.prototype.cast = function Thenable_cast() {\n  if (!this.became) {\n    var deferred = defer();\n    var thenable = this.thenable;\n    asap(function Thenable_cast_task() {\n      try {\n        thenable.then(deferred.resolve, deferred.reject);\n      } catch (exception) {\n        deferred.reject(exception);\n      }\n    });\n    this.became = Q_getHandler(deferred.promise);\n  }\n\n  return this.became;\n};\n\nThenable.prototype.dispatch = function Thenable_dispatch(resolve, op, args) {\n  this.cast().dispatch(resolve, op, args);\n};\n\nfunction Passed(promise) {\n  this.promise = promise;\n}\n\nPassed.prototype.state = \"passed\";\n\nPassed.prototype.inspect = function Passed_inspect() {\n  return this.promise.inspect();\n};\n\nPassed.prototype.dispatch = function Passed_dispatch(resolve, op, args) {\n  return this.promise.rawDispatch(resolve, op, args);\n}; // Thus begins the Q Node.js bridge\n\n/**\n * Calls a method of a Node-style object that accepts a Node-style\n * callback, forwarding the given variadic arguments, plus a provided\n * callback argument.\n * @param object an object that has the named method\n * @param {String} name name of the method of object\n * @param ...args arguments to pass to the method; the callback will\n * be provided by Q and appended to these arguments.\n * @returns a promise for the value or error\n */\n\n\nQ.ninvoke = function Q_ninvoke(object, name\n/*...args*/\n) {\n  var args = new Array(Math.max(0, arguments.length - 1));\n\n  for (var index = 2; index < arguments.length; index++) {\n    args[index - 2] = arguments[index];\n  }\n\n  var deferred = Q.defer();\n  args[index - 2] = deferred.makeNodeResolver();\n  Q(object).dispatch(\"invoke\", [name, args]).catch(deferred.reject);\n  return deferred.promise;\n};\n\nPromise.prototype.ninvoke = function Promise_ninvoke(name\n/*...args*/\n) {\n  var args = new Array(arguments.length);\n\n  for (var index = 1; index < arguments.length; index++) {\n    args[index - 1] = arguments[index];\n  }\n\n  var deferred = Q.defer();\n  args[index - 1] = deferred.makeNodeResolver();\n  this.dispatch(\"invoke\", [name, args]).catch(deferred.reject);\n  return deferred.promise;\n};\n/**\n * Wraps a Node.js continuation passing function and returns an equivalent\n * version that returns a promise.\n * @example\n * Q.denodeify(FS.readFile)(__filename, \"utf-8\")\n * .then(console.log)\n * .done()\n */\n\n\nQ.denodeify = function Q_denodeify(callback, pattern) {\n  return function denodeified() {\n    var args = new Array(arguments.length + 1);\n    var index = 0;\n\n    for (; index < arguments.length; index++) {\n      args[index] = arguments[index];\n    }\n\n    var deferred = Q.defer();\n    args[index] = deferred.makeNodeResolver(pattern);\n    Q(callback).apply(this, args).catch(deferred.reject);\n    return deferred.promise;\n  };\n};\n/**\n * Creates a Node.js-style callback that will resolve or reject the deferred\n * promise.\n * @param unpack `true` means that the Node.js-style-callback accepts a\n * fixed or variable number of arguments and that the deferred should be resolved\n * with an array of these value arguments, or rejected with the error argument.\n * An array of names means that the Node.js-style-callback accepts a fixed\n * number of arguments, and that the resolution should be an object with\n * properties corresponding to the given names and respective value arguments.\n * @returns a nodeback\n */\n\n\nDeferred.prototype.makeNodeResolver = function (unpack) {\n  var resolve = this.resolve;\n\n  if (unpack === true) {\n    return function variadicNodebackToResolver(error) {\n      if (error) {\n        resolve(Q_reject(error));\n      } else {\n        var value = new Array(Math.max(0, arguments.length - 1));\n\n        for (var index = 1; index < arguments.length; index++) {\n          value[index - 1] = arguments[index];\n        }\n\n        resolve(value);\n      }\n    };\n  } else if (unpack) {\n    return function namedArgumentNodebackToResolver(error) {\n      if (error) {\n        resolve(Q_reject(error));\n      } else {\n        var value = {};\n\n        for (var index = 0; index < unpack.length; index++) {\n          value[unpack[index]] = arguments[index + 1];\n        }\n\n        resolve(value);\n      }\n    };\n  } else {\n    return function nodebackToResolver(error, value) {\n      if (error) {\n        resolve(Q_reject(error));\n      } else {\n        resolve(value);\n      }\n    };\n  }\n};\n/**\n * TODO\n */\n\n\nPromise.prototype.nodeify = function Promise_nodeify(nodeback) {\n  if (nodeback) {\n    this.done(function (value) {\n      nodeback(null, value);\n    }, nodeback);\n  } else {\n    return this;\n  }\n}; // DEPRECATED\n\n\nQ.nextTick = deprecate(asap, \"nextTick\", \"asap package\");\nQ.resolve = deprecate(Q, \"resolve\", \"Q\");\nQ.fulfill = deprecate(Q, \"fulfill\", \"Q\");\nQ.isPromiseAlike = deprecate(isThenable, \"isPromiseAlike\", \"(not supported)\");\nQ.fail = deprecate(function (value, rejected) {\n  return Q(value).catch(rejected);\n}, \"Q.fail\", \"Q(value).catch\");\nQ.fin = deprecate(function (value, regardless) {\n  return Q(value).finally(regardless);\n}, \"Q.fin\", \"Q(value).finally\");\nQ.progress = deprecate(function (value) {\n  return value;\n}, \"Q.progress\", \"no longer supported\");\nQ.thenResolve = deprecate(function (promise, value) {\n  return Q(promise).thenResolve(value);\n}, \"thenResolve\", \"Q(value).thenResolve\");\nQ.thenReject = deprecate(function (promise, reason) {\n  return Q(promise).thenResolve(reason);\n}, \"thenResolve\", \"Q(value).thenResolve\");\nQ.isPending = deprecate(function (value) {\n  return Q(value).isPending();\n}, \"isPending\", \"Q(value).isPending\");\nQ.isFulfilled = deprecate(function (value) {\n  return Q(value).isFulfilled();\n}, \"isFulfilled\", \"Q(value).isFulfilled\");\nQ.isRejected = deprecate(function (value) {\n  return Q(value).isRejected();\n}, \"isRejected\", \"Q(value).isRejected\");\nQ.master = deprecate(function (value) {\n  return value;\n}, \"master\", \"no longer necessary\");\n\nQ.makePromise = function () {\n  throw new Error(\"makePromise is no longer supported\");\n};\n\nQ.dispatch = deprecate(function (value, op, operands) {\n  return Q(value).dispatch(op, operands);\n}, \"dispatch\", \"Q(value).dispatch\");\nQ.get = deprecate(function (object, name) {\n  return Q(object).get(name);\n}, \"get\", \"Q(value).get\");\nQ.keys = deprecate(function (object) {\n  return Q(object).keys();\n}, \"keys\", \"Q(value).keys\");\nQ.post = deprecate(function (object, name, args) {\n  return Q(object).post(name, args);\n}, \"post\", \"Q(value).invoke (spread arguments)\");\nQ.mapply = deprecate(function (object, name, args) {\n  return Q(object).post(name, args);\n}, \"post\", \"Q(value).invoke (spread arguments)\");\nQ.send = deprecate(function (object, name) {\n  return Q(object).post(name, Array.prototype.slice.call(arguments, 2));\n}, \"send\", \"Q(value).invoke\");\n\nQ.set = function () {\n  throw new Error(\"Q.set no longer supported\");\n};\n\nQ.delete = function () {\n  throw new Error(\"Q.delete no longer supported\");\n};\n\nQ.nearer = deprecate(function (value) {\n  if (Q_isPromise(value) && value.isFulfilled()) {\n    return value.inspect().value;\n  } else {\n    return value;\n  }\n}, \"nearer\", \"inspect().value (+nuances)\");\nQ.fapply = deprecate(function (callback, args) {\n  return Q(callback).dispatch(\"call\", [args]);\n}, \"fapply\", \"Q(callback).apply(thisp, args)\");\nQ.fcall = deprecate(function (callback\n/*, ...args*/\n) {\n  return Q(callback).dispatch(\"call\", [Array.prototype.slice.call(arguments, 1)]);\n}, \"fcall\", \"Q(callback).call(thisp, ...args)\");\nQ.fbind = deprecate(function (object\n/*...args*/\n) {\n  var promise = Q(object);\n  var args = Array.prototype.slice.call(arguments, 1);\n  return function fbound() {\n    return promise.dispatch(\"call\", [args.concat(Array.prototype.slice.call(arguments)), this]);\n  };\n}, \"fbind\", \"bind with thisp\");\nQ.promise = deprecate(Promise, \"promise\", \"Promise\");\nPromise.prototype.fapply = deprecate(function (args) {\n  return this.dispatch(\"call\", [args]);\n}, \"fapply\", \"apply with thisp\");\nPromise.prototype.fcall = deprecate(function\n  /*...args*/\n() {\n  return this.dispatch(\"call\", [Array.prototype.slice.call(arguments)]);\n}, \"fcall\", \"try or call with thisp\");\nPromise.prototype.fail = deprecate(function (rejected) {\n  return this.catch(rejected);\n}, \"fail\", \"catch\");\nPromise.prototype.fin = deprecate(function (regardless) {\n  return this.finally(regardless);\n}, \"fin\", \"finally\");\n\nPromise.prototype.set = function () {\n  throw new Error(\"Promise set no longer supported\");\n};\n\nPromise.prototype.delete = function () {\n  throw new Error(\"Promise delete no longer supported\");\n};\n\nDeferred.prototype.notify = deprecate(function () {}, \"notify\", \"no longer supported\");\nPromise.prototype.progress = deprecate(function () {\n  return this;\n}, \"progress\", \"no longer supported\"); // alternative proposed by Redsandro, dropped in favor of post to streamline\n// the interface\n\nPromise.prototype.mapply = deprecate(function (name, args) {\n  return this.dispatch(\"invoke\", [name, args]);\n}, \"mapply\", \"invoke\");\nPromise.prototype.fbind = deprecate(function () {\n  return Q.fbind.apply(Q, [void 0].concat(Array.prototype.slice.call(arguments)));\n}, \"fbind\", \"bind(thisp, ...args)\"); // alternative proposed by Mark Miller, dropped in favor of invoke\n\nPromise.prototype.send = deprecate(function () {\n  return this.dispatch(\"invoke\", [name, Array.prototype.slice.call(arguments, 1)]);\n}, \"send\", \"invoke\"); // alternative proposed by Redsandro, dropped in favor of invoke\n\nPromise.prototype.mcall = deprecate(function () {\n  return this.dispatch(\"invoke\", [name, Array.prototype.slice.call(arguments, 1)]);\n}, \"mcall\", \"invoke\");\nPromise.prototype.passByCopy = deprecate(function (value) {\n  return value;\n}, \"passByCopy\", \"Q.passByCopy\"); // Deprecated Node.js bridge promise methods\n\nQ.nfapply = deprecate(function (callback, args) {\n  var deferred = Q.defer();\n  var nodeArgs = Array.prototype.slice.call(args);\n  nodeArgs.push(deferred.makeNodeResolver());\n  Q(callback).apply(this, nodeArgs).catch(deferred.reject);\n  return deferred.promise;\n}, \"nfapply\");\nPromise.prototype.nfapply = deprecate(function (args) {\n  return Q.nfapply(this, args);\n}, \"nfapply\");\nQ.nfcall = deprecate(function (callback\n/*...args*/\n) {\n  var args = Array.prototype.slice.call(arguments, 1);\n  return Q.nfapply(callback, args);\n}, \"nfcall\");\nPromise.prototype.nfcall = deprecate(function () {\n  var args = new Array(arguments.length);\n\n  for (var index = 0; index < arguments.length; index++) {\n    args[index] = arguments[index];\n  }\n\n  return Q.nfapply(this, args);\n}, \"nfcall\");\nQ.nfbind = deprecate(function (callback\n/*...args*/\n) {\n  var baseArgs = Array.prototype.slice.call(arguments, 1);\n  return function () {\n    var nodeArgs = baseArgs.concat(Array.prototype.slice.call(arguments));\n    var deferred = Q.defer();\n    nodeArgs.push(deferred.makeNodeResolver());\n    Q(callback).apply(this, nodeArgs).catch(deferred.reject);\n    return deferred.promise;\n  };\n}, \"nfbind\", \"denodeify (with caveats)\");\nPromise.prototype.nfbind = deprecate(function () {\n  var args = new Array(arguments.length);\n\n  for (var index = 0; index < arguments.length; index++) {\n    args[index] = arguments[index];\n  }\n\n  return Q.nfbind(this, args);\n}, \"nfbind\", \"denodeify (with caveats)\");\nQ.nbind = deprecate(function (callback, thisp\n/*...args*/\n) {\n  var baseArgs = Array.prototype.slice.call(arguments, 2);\n  return function () {\n    var nodeArgs = baseArgs.concat(Array.prototype.slice.call(arguments));\n    var deferred = Q.defer();\n    nodeArgs.push(deferred.makeNodeResolver());\n\n    function bound() {\n      return callback.apply(thisp, arguments);\n    }\n\n    Q(bound).apply(this, nodeArgs).catch(deferred.reject);\n    return deferred.promise;\n  };\n}, \"nbind\", \"denodeify (with caveats)\");\nQ.npost = deprecate(function (object, name, nodeArgs) {\n  var deferred = Q.defer();\n  nodeArgs.push(deferred.makeNodeResolver());\n  Q(object).dispatch(\"invoke\", [name, nodeArgs]).catch(deferred.reject);\n  return deferred.promise;\n}, \"npost\", \"ninvoke (with spread arguments)\");\nPromise.prototype.npost = deprecate(function (name, args) {\n  return Q.npost(this, name, args);\n}, \"npost\", \"Q.ninvoke (with caveats)\");\nQ.nmapply = deprecate(Q.nmapply, \"nmapply\", \"q/node nmapply\");\nPromise.prototype.nmapply = deprecate(Promise.prototype.npost, \"nmapply\", \"Q.nmapply\");\nQ.nsend = deprecate(Q.ninvoke, \"nsend\", \"q/node ninvoke\");\nQ.nmcall = deprecate(Q.ninvoke, \"nmcall\", \"q/node ninvoke\");\nPromise.prototype.nsend = deprecate(Promise.prototype.ninvoke, \"nsend\", \"q/node ninvoke\");\nPromise.prototype.nmcall = deprecate(Promise.prototype.ninvoke, \"nmcall\", \"q/node ninvoke\"); // All code before this point will be filtered from stack traces.\n\nvar qEndingLine = captureLine();","map":{"version":3,"names":["hasStacks","Error","e","stack","qStartingLine","captureLine","qFileName","WeakMap","require","iterate","asap","isObject","value","Object","STACK_JUMP_SEPARATOR","makeStackTraceLong","error","promise","indexOf","stacks","p","handlers","get","became","unshift","concatedStacks","join","filterStackString","stackString","Q","isIntrospective","lines","split","desiredLines","i","length","line","isInternalFrame","isNodeFrame","push","stackLine","getFileNameAndLineNumber","attempt1","exec","Number","attempt2","attempt3","fileNameAndLineNumber","fileName","lineNumber","qEndingLine","firstLine","deprecate","callback","name","alternative","Q_deprecate","console","warn","apply","arguments","Q_getHandler","handler","follow","set","theViciousCycleError","theViciousCycleRejection","Q_reject","theViciousCycle","thenables","module","exports","Q_isPromise","isThenable","has","Promise","Thenable","Fulfilled","longStackSupport","reject","Rejected","defer","Pending","deferred","Deferred","substring","when","Q_when","fulfilled","rejected","ms","then","all","Q_all","questions","countDown","answers","Array","estimates","estimate","Infinity","setEstimate","prototype","forEach","call","Q_all_each","index","state","Q_all_eachFulfilled","resolve","observeEstimate","Q_all_eachEstimate","newEstimate","oldEstimate","computeEstimate","allSettled","Q_allSettled","map","Q_allSettled_each","regardless","inspect","delay","Q_delay","object","timeout","Q_timeout","message","spread","Q_spread","Q_join","x","y","Q_joined","race","Q_race","answerPs","answerP","try","Q_try","dispatch","function","Promise_function","wrapped","promiseFunctionWrapper","args","promised","Q_promised","promisedMethod","Q_promised_spread","self","passByCopy","passByCopies","isPortable","async","Q_async","makeGenerator","spawn","continuer","verb","arg","iteration","generator","exception","done","errback","bind","Q_spawn","setup","Promise_resolve","isPromise","Promise_inspect","isPending","Promise_isPending","isFulfilled","Promise_isFulfilled","isRejected","Promise_isRejected","toBePassed","Promise_toBePassed","toString","Promise_toString","Promise_then","_fulfilled","Promise_then_fulfilled","_rejected","Promise_then_rejected","newError","updateEstimate","Promise_then_updateEstimate","getEstimate","Promise_done","Promise_done_task","onerror","Promise_done_fulfilled","Promise_rethrow","Promise_done_rejected","process","domain","thenResolve","Promise_thenResolve","Promise_thenResolve_resolved","thenReject","Promise_thenReject","Promise_thenReject_resolved","Promise_all","Promise_allSettled","catch","Promise_catch","finally","Promise_finally","Promise_finally_fulfilled","reason","Promise_finally_rejected","Promise_observeEstimate","emit","rawDispatch","Promise_getEstimate","Promise_dispatch","op","Promise_rawDispatch","Promise_dispatch_task","Promise_get","invoke","Promise_invoke","Promise_apply","thisp","Promise_call","Math","max","Promise_bind","Promise_bind_bound","boundArgs","slice","keys","Promise_keys","Promise_iterate","Promise_spread","Promise_spread_fulfilled","array","Promsie_timeout","timeoutId","setTimeout","Promise_timeout_task","Promise_timeout_fulfilled","clearTimeout","Promise_timeout_rejected","Promise_delay","Promise_delay_fulfilled","Date","now","Promise_delay_task","pull","Promise_pull","pass","Promise_pass","Passed","promises","Deferred_resolve","messages","become","Deferred_reject","Deferred_setEstimate","Fulfilled_inspect","Fulfilled_dispatch","operands","result","Fulfilled_then","Fulfilled_get","Fulfilled_call","callInvoke","Fulfilled_invoke","Fulfilled_callInvoke","waitToBePassed","Fulfilled_keys","Fulfilled_iterate","Fulfilled_pull","isArray","Rejected_inspect","Rejected_dispatch","Rejected_then","observers","Pending_inspect","Pending_dispatch","Pending_dispatch_task","Pending_become","Pending_become_eachMessage","Pending_become_eachMessage_task","Pending_setEstimate","Pending_eachObserver","observer","Pending_setEstimate_eachObserver_task","thenable","Thenable_inspect","cast","Thenable_cast","Thenable_cast_task","Thenable_dispatch","Passed_inspect","Passed_dispatch","ninvoke","Q_ninvoke","makeNodeResolver","Promise_ninvoke","denodeify","Q_denodeify","pattern","denodeified","unpack","variadicNodebackToResolver","namedArgumentNodebackToResolver","nodebackToResolver","nodeify","Promise_nodeify","nodeback","nextTick","fulfill","isPromiseAlike","fail","fin","progress","master","makePromise","post","mapply","send","delete","nearer","fapply","fcall","fbind","fbound","concat","notify","mcall","nfapply","nodeArgs","nfcall","nfbind","baseArgs","nbind","bound","npost","nmapply","nsend","nmcall"],"sources":["/Users/hooniesun/rmit/fwp/assessment1/lan/node_modules/twilio/node_modules/q/q.js"],"sourcesContent":["/* vim:ts=4:sts=4:sw=4: */\n/*!\n *\n * Copyright 2009-2013 Kris Kowal under the terms of the MIT\n * license found at http://github.com/kriskowal/q/raw/master/LICENSE\n *\n * With parts by Tyler Close\n * Copyright 2007-2009 Tyler Close under the terms of the MIT X license found\n * at http://www.opensource.org/licenses/mit-license.html\n * Forked at ref_send.js version: 2009-05-11\n *\n * With parts by Mark Miller\n * Copyright (C) 2011 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n/*global -WeakMap */\n\"use strict\";\n\nvar hasStacks = false;\ntry {\n    throw new Error();\n} catch (e) {\n    hasStacks = !!e.stack;\n}\n\n// All code after this point will be filtered from stack traces reported\n// by Q.\nvar qStartingLine = captureLine();\nvar qFileName;\n\nvar WeakMap = require(\"weak-map\");\nvar iterate = require(\"pop-iterate\");\nvar asap = require(\"asap\");\n\nfunction isObject(value) {\n    return value === Object(value);\n}\n\n// long stack traces\n\nvar STACK_JUMP_SEPARATOR = \"From previous event:\";\n\nfunction makeStackTraceLong(error, promise) {\n    // If possible, transform the error stack trace by removing Node and Q\n    // cruft, then concatenating with the stack trace of `promise`. See #57.\n    if (hasStacks &&\n        promise.stack &&\n        typeof error === \"object\" &&\n        error !== null &&\n        error.stack &&\n        error.stack.indexOf(STACK_JUMP_SEPARATOR) === -1\n    ) {\n        var stacks = [];\n        for (var p = promise; !!p && handlers.get(p); p = handlers.get(p).became) {\n            if (p.stack) {\n                stacks.unshift(p.stack);\n            }\n        }\n        stacks.unshift(error.stack);\n\n        var concatedStacks = stacks.join(\"\\n\" + STACK_JUMP_SEPARATOR + \"\\n\");\n        error.stack = filterStackString(concatedStacks);\n    }\n}\n\nfunction filterStackString(stackString) {\n    if (Q.isIntrospective) {\n        return stackString;\n    }\n    var lines = stackString.split(\"\\n\");\n    var desiredLines = [];\n    for (var i = 0; i < lines.length; ++i) {\n        var line = lines[i];\n\n        if (!isInternalFrame(line) && !isNodeFrame(line) && line) {\n            desiredLines.push(line);\n        }\n    }\n    return desiredLines.join(\"\\n\");\n}\n\nfunction isNodeFrame(stackLine) {\n    return stackLine.indexOf(\"(module.js:\") !== -1 ||\n           stackLine.indexOf(\"(node.js:\") !== -1;\n}\n\nfunction getFileNameAndLineNumber(stackLine) {\n    // Named functions: \"at functionName (filename:lineNumber:columnNumber)\"\n    // In IE10 function name can have spaces (\"Anonymous function\") O_o\n    var attempt1 = /at .+ \\((.+):(\\d+):(?:\\d+)\\)$/.exec(stackLine);\n    if (attempt1) {\n        return [attempt1[1], Number(attempt1[2])];\n    }\n\n    // Anonymous functions: \"at filename:lineNumber:columnNumber\"\n    var attempt2 = /at ([^ ]+):(\\d+):(?:\\d+)$/.exec(stackLine);\n    if (attempt2) {\n        return [attempt2[1], Number(attempt2[2])];\n    }\n\n    // Firefox style: \"function@filename:lineNumber or @filename:lineNumber\"\n    var attempt3 = /.*@(.+):(\\d+)$/.exec(stackLine);\n    if (attempt3) {\n        return [attempt3[1], Number(attempt3[2])];\n    }\n}\n\nfunction isInternalFrame(stackLine) {\n    var fileNameAndLineNumber = getFileNameAndLineNumber(stackLine);\n\n    if (!fileNameAndLineNumber) {\n        return false;\n    }\n\n    var fileName = fileNameAndLineNumber[0];\n    var lineNumber = fileNameAndLineNumber[1];\n\n    return fileName === qFileName &&\n        lineNumber >= qStartingLine &&\n        lineNumber <= qEndingLine;\n}\n\n// discover own file name and line number range for filtering stack\n// traces\nfunction captureLine() {\n    if (!hasStacks) {\n        return;\n    }\n\n    try {\n        throw new Error();\n    } catch (e) {\n        var lines = e.stack.split(\"\\n\");\n        var firstLine = lines[0].indexOf(\"@\") > 0 ? lines[1] : lines[2];\n        var fileNameAndLineNumber = getFileNameAndLineNumber(firstLine);\n        if (!fileNameAndLineNumber) {\n            return;\n        }\n\n        qFileName = fileNameAndLineNumber[0];\n        return fileNameAndLineNumber[1];\n    }\n}\n\nfunction deprecate(callback, name, alternative) {\n    return function Q_deprecate() {\n        if (\n            typeof console !== \"undefined\" &&\n            typeof console.warn === \"function\"\n        ) {\n            if (alternative) {\n                console.warn(\n                    name + \" is deprecated, use \" + alternative + \" instead.\",\n                    new Error(\"\").stack\n                );\n            } else {\n                console.warn(\n                    name + \" is deprecated.\",\n                    new Error(\"\").stack\n                );\n            }\n        }\n        return callback.apply(this, arguments);\n    };\n}\n\n// end of long stack traces\n\nvar handlers = new WeakMap();\n\nfunction Q_getHandler(promise) {\n    var handler = handlers.get(promise);\n    if (!handler || !handler.became) {\n        return handler;\n    }\n    handler = follow(handler);\n    handlers.set(promise, handler);\n    return handler;\n}\n\nfunction follow(handler) {\n    if (!handler.became) {\n        return handler;\n    } else {\n        handler.became = follow(handler.became);\n        return handler.became;\n    }\n}\n\nvar theViciousCycleError = new Error(\"Can't resolve a promise with itself\");\nvar theViciousCycleRejection = Q_reject(theViciousCycleError);\nvar theViciousCycle = Q_getHandler(theViciousCycleRejection);\n\nvar thenables = new WeakMap();\n\n/**\n * Coerces a value to a promise. If the value is a promise, pass it through\n * unaltered. If the value has a `then` method, it is presumed to be a promise\n * but not one of our own, so it is treated as a “thenable” promise and this\n * returns a promise that stands for it. Otherwise, this returns a promise that\n * has already been fulfilled with the value.\n * @param value promise, object with a then method, or a fulfillment value\n * @returns {Promise} the same promise as given, or a promise for the given\n * value\n */\nmodule.exports = Q;\nfunction Q(value) {\n    // If the object is already a Promise, return it directly.  This enables\n    // the resolve function to both be used to created references from objects,\n    // but to tolerably coerce non-promises to promises.\n    if (Q_isPromise(value)) {\n        return value;\n    } else if (isThenable(value)) {\n        if (!thenables.has(value)) {\n            thenables.set(value, new Promise(new Thenable(value)));\n        }\n        return thenables.get(value);\n    } else {\n        return new Promise(new Fulfilled(value));\n    }\n}\n\n/**\n * Controls whether or not long stack traces will be on\n * @type {boolean}\n */\nQ.longStackSupport = false;\n\n/**\n * Returns a promise that has been rejected with a reason, which should be an\n * instance of `Error`.\n * @param {Error} error reason for the failure.\n * @returns {Promise} rejection\n */\nQ.reject = Q_reject;\nfunction Q_reject(error) {\n    return new Promise(new Rejected(error));\n}\n\n/**\n * Constructs a {promise, resolve, reject} object.\n *\n * `resolve` is a callback to invoke with a more resolved value for the\n * promise. To fulfill the promise, invoke `resolve` with any value that is\n * not a thenable. To reject the promise, invoke `resolve` with a rejected\n * thenable, or invoke `reject` with the reason directly. To resolve the\n * promise to another thenable, thus putting it in the same state, invoke\n * `resolve` with that other thenable.\n *\n * @returns {{promise, resolve, reject}} a deferred\n */\nQ.defer = defer;\nfunction defer() {\n\n    var handler = new Pending();\n    var promise = new Promise(handler);\n    var deferred = new Deferred(promise);\n\n    if (Q.longStackSupport && hasStacks) {\n        try {\n            throw new Error();\n        } catch (e) {\n            // NOTE: don't try to use `Error.captureStackTrace` or transfer the\n            // accessor around; that causes memory leaks as per GH-111. Just\n            // reify the stack trace as a string ASAP.\n            //\n            // At the same time, cut off the first line; it's always just\n            // \"[object Promise]\\n\", as per the `toString`.\n            promise.stack = e.stack.substring(e.stack.indexOf(\"\\n\") + 1);\n        }\n    }\n\n    return deferred;\n}\n\n// TODO\n/**\n */\nQ.when = function Q_when(value, fulfilled, rejected, ms) {\n    return Q(value).then(fulfilled, rejected, ms);\n};\n\n/**\n * Turns an array of promises into a promise for an array.  If any of the\n * promises gets rejected, the whole array is rejected immediately.\n * @param {Array.<Promise>} an array (or promise for an array) of values (or\n * promises for values)\n * @returns {Promise.<Array>} a promise for an array of the corresponding values\n */\n// By Mark Miller\n// http://wiki.ecmascript.org/doku.php?id=strawman:concurrency&rev=1308776521#allfulfilled\nQ.all = Q_all;\nfunction Q_all(questions) {\n    // XXX deprecated behavior\n    if (Q_isPromise(questions)) {\n        if (\n            typeof console !== \"undefined\" &&\n            typeof console.warn === \"function\"\n        ) {\n            console.warn(\"Q.all no longer directly unwraps a promise. Use Q(array).all()\");\n        }\n        return Q(questions).all();\n    }\n    var countDown = 0;\n    var deferred = defer();\n    var answers = Array(questions.length);\n    var estimates = [];\n    var estimate = -Infinity;\n    var setEstimate;\n    Array.prototype.forEach.call(questions, function Q_all_each(promise, index) {\n        var handler;\n        if (\n            Q_isPromise(promise) &&\n            (handler = Q_getHandler(promise)).state === \"fulfilled\"\n        ) {\n            answers[index] = handler.value;\n        } else {\n            ++countDown;\n            promise = Q(promise);\n            promise.then(\n                function Q_all_eachFulfilled(value) {\n                    answers[index] = value;\n                    if (--countDown === 0) {\n                        deferred.resolve(answers);\n                    }\n                },\n                deferred.reject\n            );\n\n            promise.observeEstimate(function Q_all_eachEstimate(newEstimate) {\n                var oldEstimate = estimates[index];\n                estimates[index] = newEstimate;\n                if (newEstimate > estimate) {\n                    estimate = newEstimate;\n                } else if (oldEstimate === estimate && newEstimate <= estimate) {\n                    // There is a 1/length chance that we will need to perform\n                    // this O(length) walk, so amortized O(1)\n                    computeEstimate();\n                }\n                if (estimates.length === questions.length && estimate !== setEstimate) {\n                    deferred.setEstimate(estimate);\n                    setEstimate = estimate;\n                }\n            });\n\n        }\n    });\n\n    function computeEstimate() {\n        estimate = -Infinity;\n        for (var index = 0; index < estimates.length; index++) {\n            if (estimates[index] > estimate) {\n                estimate = estimates[index];\n            }\n        }\n    }\n\n    if (countDown === 0) {\n        deferred.resolve(answers);\n    }\n\n    return deferred.promise;\n}\n\n/**\n * @see Promise#allSettled\n */\nQ.allSettled = Q_allSettled;\nfunction Q_allSettled(questions) {\n    // XXX deprecated behavior\n    if (Q_isPromise(questions)) {\n        if (\n            typeof console !== \"undefined\" &&\n            typeof console.warn === \"function\"\n        ) {\n            console.warn(\"Q.allSettled no longer directly unwraps a promise. Use Q(array).allSettled()\");\n        }\n        return Q(questions).allSettled();\n    }\n    return Q_all(questions.map(function Q_allSettled_each(promise) {\n        promise = Q(promise);\n        function regardless() {\n            return promise.inspect();\n        }\n        return promise.then(regardless, regardless);\n    }));\n}\n\n/**\n * Returns a promise for the given value (or promised value), some\n * milliseconds after it resolved. Passes rejections immediately.\n * @param {Any*} promise\n * @param {Number} milliseconds\n * @returns a promise for the resolution of the given promise after milliseconds\n * time has elapsed since the resolution of the given promise.\n * If the given promise rejects, that is passed immediately.\n */\nQ.delay = function Q_delay(object, timeout) {\n    if (timeout === void 0) {\n        timeout = object;\n        object = void 0;\n    }\n    return Q(object).delay(timeout);\n};\n\n/**\n * Causes a promise to be rejected if it does not get fulfilled before\n * some milliseconds time out.\n * @param {Any*} promise\n * @param {Number} milliseconds timeout\n * @param {String} custom error message (optional)\n * @returns a promise for the resolution of the given promise if it is\n * fulfilled before the timeout, otherwise rejected.\n */\nQ.timeout = function Q_timeout(object, ms, message) {\n    return Q(object).timeout(ms, message);\n};\n\n/**\n * Spreads the values of a promised array of arguments into the\n * fulfillment callback.\n * @param fulfilled callback that receives variadic arguments from the\n * promised array\n * @param rejected callback that receives the exception if the promise\n * is rejected.\n * @returns a promise for the return value or thrown exception of\n * either callback.\n */\nQ.spread = Q_spread;\nfunction Q_spread(value, fulfilled, rejected) {\n    return Q(value).spread(fulfilled, rejected);\n}\n\n/**\n * If two promises eventually fulfill to the same value, promises that value,\n * but otherwise rejects.\n * @param x {Any*}\n * @param y {Any*}\n * @returns {Any*} a promise for x and y if they are the same, but a rejection\n * otherwise.\n *\n */\nQ.join = function Q_join(x, y) {\n    return Q.spread([x, y], function Q_joined(x, y) {\n        if (x === y) {\n            // TODO: \"===\" should be Object.is or equiv\n            return x;\n        } else {\n            throw new Error(\"Can't join: not the same: \" + x + \" \" + y);\n        }\n    });\n};\n\n/**\n * Returns a promise for the first of an array of promises to become fulfilled.\n * @param answers {Array} promises to race\n * @returns {Promise} the first promise to be fulfilled\n */\nQ.race = Q_race;\nfunction Q_race(answerPs) {\n    return new Promise(function(deferred) {\n        answerPs.forEach(function(answerP) {\n            Q(answerP).then(deferred.resolve, deferred.reject);\n        });\n    });\n}\n\n/**\n * Calls the promised function in a future turn.\n * @param object    promise or immediate reference for target function\n * @param ...args   array of application arguments\n */\nQ.try = function Q_try(callback) {\n    return Q(callback).dispatch(\"call\", [[]]);\n};\n\n/**\n * TODO\n */\nQ.function = Promise_function;\nfunction Promise_function(wrapped) {\n    return function promiseFunctionWrapper() {\n        var args = new Array(arguments.length);\n        for (var index = 0; index < arguments.length; index++) {\n            args[index] = arguments[index];\n        }\n        return Q(wrapped).apply(this, args);\n    };\n}\n\n/**\n * The promised function decorator ensures that any promise arguments\n * are settled and passed as values (`this` is also settled and passed\n * as a value).  It will also ensure that the result of a function is\n * always a promise.\n *\n * @example\n * var add = Q.promised(function (a, b) {\n *     return a + b;\n * });\n * add(Q(a), Q(B));\n *\n * @param {function} callback The function to decorate\n * @returns {function} a function that has been decorated.\n */\nQ.promised = function Q_promised(callback) {\n    return function promisedMethod() {\n        var args = new Array(arguments.length);\n        for (var index = 0; index < arguments.length; index++) {\n            args[index] = arguments[index];\n        }\n        return Q_spread(\n            [this, Q_all(args)],\n            function Q_promised_spread(self, args) {\n                return callback.apply(self, args);\n            }\n        );\n    };\n};\n\n/**\n */\nQ.passByCopy = // TODO XXX experimental\nQ.push = function (value) {\n    if (Object(value) === value && !Q_isPromise(value)) {\n        passByCopies.set(value, true);\n    }\n    return value;\n};\n\nQ.isPortable = function (value) {\n    return Object(value) === value && passByCopies.has(value);\n};\n\nvar passByCopies = new WeakMap();\n\n/**\n * The async function is a decorator for generator functions, turning\n * them into asynchronous generators. Although generators are only\n * part of the newest ECMAScript 6 drafts, this code does not cause\n * syntax errors in older engines. This code should continue to work\n * and will in fact improve over time as the language improves.\n *\n * ES6 generators are currently part of V8 version 3.19 with the\n * `--harmony-generators` runtime flag enabled. This function does not\n * support the former, Pythonic generators that were only implemented\n * by SpiderMonkey.\n *\n * Decorates a generator function such that:\n *  - it may yield promises\n *  - execution will continue when that promise is fulfilled\n *  - the value of the yield expression will be the fulfilled value\n *  - it returns a promise for the return value (when the generator\n *    stops iterating)\n *  - the decorated function returns a promise for the return value\n *    of the generator or the first rejected promise among those\n *    yielded.\n *  - if an error is thrown in the generator, it propagates through\n *    every following yield until it is caught, or until it escapes\n *    the generator function altogether, and is translated into a\n *    rejection for the promise returned by the decorated generator.\n */\nQ.async = Q_async;\nfunction Q_async(makeGenerator) {\n    return function spawn() {\n        // when verb is \"send\", arg is a value\n        // when verb is \"throw\", arg is an exception\n        function continuer(verb, arg) {\n            var iteration;\n            try {\n                iteration = generator[verb](arg);\n            } catch (exception) {\n                return Q_reject(exception);\n            }\n            if (iteration.done) {\n                return Q(iteration.value);\n            } else {\n                return Q(iteration.value).then(callback, errback);\n            }\n        }\n        var generator = makeGenerator.apply(this, arguments);\n        var callback = continuer.bind(continuer, \"next\");\n        var errback = continuer.bind(continuer, \"throw\");\n        return callback();\n    };\n}\n\n/**\n * The spawn function is a small wrapper around async that immediately\n * calls the generator and also ends the promise chain, so that any\n * unhandled errors are thrown instead of forwarded to the error\n * handler. This is useful because it's extremely common to run\n * generators at the top-level to work with libraries.\n */\nQ.spawn = Q_spawn;\nfunction Q_spawn(makeGenerator) {\n    Q_async(makeGenerator)().done();\n}\n\n\n// Thus begins the section dedicated to the Promise\n\n/**\n * TODO\n */\nQ.Promise = Promise;\nfunction Promise(handler) {\n    if (!(this instanceof Promise)) {\n        return new Promise(handler);\n    }\n    if (typeof handler === \"function\") {\n        var setup = handler;\n        var deferred = defer();\n        handler = Q_getHandler(deferred.promise);\n        try {\n            setup(deferred.resolve, deferred.reject, deferred.setEstimate);\n        } catch (error) {\n            deferred.reject(error);\n        }\n    }\n    handlers.set(this, handler);\n}\n\n/**\n * Turns an array of promises into a promise for an array.  If any of the\n * promises gets rejected, the whole array is rejected immediately.\n * @param {Array.<Promise>} an array (or promise for an array) of values (or\n * promises for values)\n * @returns {Promise.<Array>} a promise for an array of the corresponding values\n */\nPromise.all = Q_all;\n\n/**\n * Returns a promise for the first of an array of promises to become fulfilled.\n * @param answers {Array} promises to race\n * @returns {Promise} the first promise to be fulfilled\n */\nPromise.race = Q_race;\n\n/**\n * Coerces a value to a promise. If the value is a promise, pass it through\n * unaltered. If the value has a `then` method, it is presumed to be a promise\n * but not one of our own, so it is treated as a “thenable” promise and this\n * returns a promise that stands for it. Otherwise, this returns a promise that\n * has already been fulfilled with the value.\n * @param value promise, object with a then method, or a fulfillment value\n * @returns {Promise} the same promise as given, or a promise for the given\n * value\n */\nPromise.resolve = Promise_resolve;\nfunction Promise_resolve(value) {\n    return Q(value);\n}\n\n/**\n * Returns a promise that has been rejected with a reason, which should be an\n * instance of `Error`.\n * @param reason value describing the failure\n * @returns {Promise} rejection\n */\nPromise.reject = Q_reject;\n\n/**\n * @returns {boolean} whether the given value is a promise.\n */\nQ.isPromise = Q_isPromise;\nfunction Q_isPromise(object) {\n    return isObject(object) && !!handlers.get(object);\n}\n\n/**\n * @returns {boolean} whether the given value is an object with a then method.\n * @private\n */\nfunction isThenable(object) {\n    return isObject(object) && typeof object.then === \"function\";\n}\n\n/**\n * Synchronously produces a snapshot of the internal state of the promise.  The\n * object will have a `state` property. If the `state` is `\"pending\"`, there\n * will be no further information. If the `state` is `\"fulfilled\"`, there will\n * be a `value` property. If the state is `\"rejected\"` there will be a `reason`\n * property.  If the promise was constructed from a “thenable” and `then` nor\n * any other method has been dispatched on the promise has been called, the\n * state will be `\"pending\"`. The state object will not be updated if the\n * state changes and changing it will have no effect on the promise. Every\n * call to `inspect` produces a unique object.\n * @returns {{state: string, value?, reason?}}\n */\nPromise.prototype.inspect = function Promise_inspect() {\n    // the second layer captures only the relevant \"state\" properties of the\n    // handler to prevent leaking the capability to access or alter the\n    // handler.\n    return Q_getHandler(this).inspect();\n};\n\n/**\n * @returns {boolean} whether the promise is waiting for a result.\n */\nPromise.prototype.isPending = function Promise_isPending() {\n    return Q_getHandler(this).state === \"pending\";\n};\n\n/**\n * @returns {boolean} whether the promise has ended in a result and has a\n * fulfillment value.\n */\nPromise.prototype.isFulfilled = function Promise_isFulfilled() {\n    return Q_getHandler(this).state === \"fulfilled\";\n};\n\n/**\n * @returns {boolean} whether the promise has ended poorly and has a reason for\n * its rejection.\n */\nPromise.prototype.isRejected = function Promise_isRejected() {\n    return Q_getHandler(this).state === \"rejected\";\n};\n\n/**\n * TODO\n */\nPromise.prototype.toBePassed = function Promise_toBePassed() {\n    return Q_getHandler(this).state === \"passed\";\n};\n\n/**\n * @returns {string} merely `\"[object Promise]\"`\n */\nPromise.prototype.toString = function Promise_toString() {\n    return \"[object Promise]\";\n};\n\n/**\n * Creates a new promise, waits for this promise to be resolved, and informs\n * either the fullfilled or rejected handler of the result. Whatever result\n * comes of the fulfilled or rejected handler, a value returned, a promise\n * returned, or an error thrown, becomes the resolution for the promise\n * returned by `then`.\n *\n * @param fulfilled\n * @param rejected\n * @returns {Promise} for the result of `fulfilled` or `rejected`.\n */\nPromise.prototype.then = function Promise_then(fulfilled, rejected, ms) {\n    var self = this;\n    var deferred = defer();\n\n    var _fulfilled;\n    if (typeof fulfilled === \"function\") {\n        _fulfilled = function Promise_then_fulfilled(value) {\n            try {\n                deferred.resolve(fulfilled.call(void 0, value));\n            } catch (error) {\n                deferred.reject(error);\n            }\n        };\n    } else {\n        _fulfilled = deferred.resolve;\n    }\n\n    var _rejected;\n    if (typeof rejected === \"function\") {\n        _rejected = function Promise_then_rejected(error) {\n            try {\n                deferred.resolve(rejected.call(void 0, error));\n            } catch (newError) {\n                deferred.reject(newError);\n            }\n        };\n    } else {\n        _rejected = deferred.reject;\n    }\n\n    this.done(_fulfilled, _rejected);\n\n    if (ms !== void 0) {\n        var updateEstimate = function Promise_then_updateEstimate() {\n            deferred.setEstimate(self.getEstimate() + ms);\n        };\n        this.observeEstimate(updateEstimate);\n        updateEstimate();\n    }\n\n    return deferred.promise;\n};\n\n/**\n * Terminates a chain of promises, forcing rejections to be\n * thrown as exceptions.\n * @param fulfilled\n * @param rejected\n */\nPromise.prototype.done = function Promise_done(fulfilled, rejected) {\n    var self = this;\n    var done = false;   // ensure the untrusted promise makes at most a\n                        // single call to one of the callbacks\n    asap(function Promise_done_task() {\n        var _fulfilled;\n        if (typeof fulfilled === \"function\") {\n            if (Q.onerror) {\n                _fulfilled = function Promise_done_fulfilled(value) {\n                    if (done) {\n                        return;\n                    }\n                    done = true;\n                    try {\n                        fulfilled.call(void 0, value);\n                    } catch (error) {\n                        // fallback to rethrow is still necessary because\n                        // _fulfilled is not called in the same event as the\n                        // above guard.\n                        (Q.onerror || Promise_rethrow)(error);\n                    }\n                };\n            } else {\n                _fulfilled = function Promise_done_fulfilled(value) {\n                    if (done) {\n                        return;\n                    }\n                    done = true;\n                    fulfilled.call(void 0, value);\n                };\n            }\n        }\n\n        var _rejected;\n        if (typeof rejected === \"function\" && Q.onerror) {\n            _rejected = function Promise_done_rejected(error) {\n                if (done) {\n                    return;\n                }\n                done = true;\n                makeStackTraceLong(error, self);\n                try {\n                    rejected.call(void 0, error);\n                } catch (newError) {\n                    (Q.onerror || Promise_rethrow)(newError);\n                }\n            };\n        } else if (typeof rejected === \"function\") {\n            _rejected = function Promise_done_rejected(error) {\n                if (done) {\n                    return;\n                }\n                done = true;\n                makeStackTraceLong(error, self);\n                rejected.call(void 0, error);\n            };\n        } else {\n            _rejected = Q.onerror || Promise_rethrow;\n        }\n\n        if (typeof process === \"object\" && process.domain) {\n            _rejected = process.domain.bind(_rejected);\n        }\n\n        Q_getHandler(self).dispatch(_fulfilled, \"then\", [_rejected]);\n    });\n};\n\nfunction Promise_rethrow(error) {\n    throw error;\n}\n\n/**\n * TODO\n */\nPromise.prototype.thenResolve = function Promise_thenResolve(value) {\n    // Wrapping ahead of time to forestall multiple wrappers.\n    value = Q(value);\n    // Using all is necessary to aggregate the estimated time to completion.\n    return Q_all([this, value]).then(function Promise_thenResolve_resolved() {\n        return value;\n    }, null, 0);\n    // 0: does not contribute significantly to the estimated time to\n    // completion.\n};\n\n/**\n * TODO\n */\nPromise.prototype.thenReject = function Promise_thenReject(error) {\n    return this.then(function Promise_thenReject_resolved() {\n        throw error;\n    }, null, 0);\n    // 0: does not contribute significantly to the estimated time to\n    // completion.\n};\n\n/**\n * TODO\n */\nPromise.prototype.all = function Promise_all() {\n    return this.then(Q_all);\n};\n\n/**\n * Turns an array of promises into a promise for an array of their states (as\n * returned by `inspect`) when they have all settled.\n * @param {Array[Any*]} values an array (or promise for an array) of values (or\n * promises for values)\n * @returns {Array[State]} an array of states for the respective values.\n */\nPromise.prototype.allSettled = function Promise_allSettled() {\n    return this.then(Q_allSettled);\n};\n\n/**\n * TODO\n */\nPromise.prototype.catch = function Promise_catch(rejected) {\n    return this.then(void 0, rejected);\n};\n\n/**\n * TODO\n */\nPromise.prototype.finally = function Promise_finally(callback, ms) {\n    if (!callback) {\n        return this;\n    }\n    callback = Q(callback);\n    return this.then(function (value) {\n        return callback.call().then(function Promise_finally_fulfilled() {\n            return value;\n        });\n    }, function (reason) {\n        // TODO attempt to recycle the rejection with \"this\".\n        return callback.call().then(function Promise_finally_rejected() {\n            throw reason;\n        });\n    }, ms);\n};\n\n/**\n * TODO\n */\nPromise.prototype.observeEstimate = function Promise_observeEstimate(emit) {\n    this.rawDispatch(null, \"estimate\", [emit]);\n    return this;\n};\n\n/**\n * TODO\n */\nPromise.prototype.getEstimate = function Promise_getEstimate() {\n    return Q_getHandler(this).estimate;\n};\n\n/**\n * TODO\n */\nPromise.prototype.dispatch = function Promise_dispatch(op, args) {\n    var deferred = defer();\n    this.rawDispatch(deferred.resolve, op, args);\n    return deferred.promise;\n};\n\n/**\n */\nPromise.prototype.rawDispatch = function Promise_rawDispatch(resolve, op, args) {\n    var self = this;\n    asap(function Promise_dispatch_task() {\n        Q_getHandler(self).dispatch(resolve, op, args);\n    });\n};\n\n/**\n * TODO\n */\nPromise.prototype.get = function Promise_get(name) {\n    return this.dispatch(\"get\", [name]);\n};\n\n/**\n * TODO\n */\nPromise.prototype.invoke = function Promise_invoke(name /*...args*/) {\n    var args = new Array(arguments.length - 1);\n    for (var index = 1; index < arguments.length; index++) {\n        args[index - 1] = arguments[index];\n    }\n    return this.dispatch(\"invoke\", [name, args]);\n};\n\n/**\n * TODO\n */\nPromise.prototype.apply = function Promise_apply(thisp, args) {\n    return this.dispatch(\"call\", [args, thisp]);\n};\n\n/**\n * TODO\n */\nPromise.prototype.call = function Promise_call(thisp /*, ...args*/) {\n    var args = new Array(Math.max(0, arguments.length - 1));\n    for (var index = 1; index < arguments.length; index++) {\n        args[index - 1] = arguments[index];\n    }\n    return this.dispatch(\"call\", [args, thisp]);\n};\n\n/**\n * TODO\n */\nPromise.prototype.bind = function Promise_bind(thisp /*, ...args*/) {\n    var self = this;\n    var args = new Array(Math.max(0, arguments.length - 1));\n    for (var index = 1; index < arguments.length; index++) {\n        args[index - 1] = arguments[index];\n    }\n    return function Promise_bind_bound(/*...args*/) {\n        var boundArgs = args.slice();\n        for (var index = 0; index < arguments.length; index++) {\n            boundArgs[boundArgs.length] = arguments[index];\n        }\n        return self.dispatch(\"call\", [boundArgs, thisp]);\n    };\n};\n\n/**\n * TODO\n */\nPromise.prototype.keys = function Promise_keys() {\n    return this.dispatch(\"keys\", []);\n};\n\n/**\n * TODO\n */\nPromise.prototype.iterate = function Promise_iterate() {\n    return this.dispatch(\"iterate\", []);\n};\n\n/**\n * TODO\n */\nPromise.prototype.spread = function Promise_spread(fulfilled, rejected, ms) {\n    return this.all().then(function Promise_spread_fulfilled(array) {\n        return fulfilled.apply(void 0, array);\n    }, rejected, ms);\n};\n\n/**\n * Causes a promise to be rejected if it does not get fulfilled before\n * some milliseconds time out.\n * @param {Number} milliseconds timeout\n * @param {String} custom error message (optional)\n * @returns a promise for the resolution of the given promise if it is\n * fulfilled before the timeout, otherwise rejected.\n */\nPromise.prototype.timeout = function Promsie_timeout(ms, message) {\n    var deferred = defer();\n    var timeoutId = setTimeout(function Promise_timeout_task() {\n        deferred.reject(new Error(message || \"Timed out after \" + ms + \" ms\"));\n    }, ms);\n\n    this.then(function Promise_timeout_fulfilled(value) {\n        clearTimeout(timeoutId);\n        deferred.resolve(value);\n    }, function Promise_timeout_rejected(error) {\n        clearTimeout(timeoutId);\n        deferred.reject(error);\n    });\n\n    return deferred.promise;\n};\n\n/**\n * Returns a promise for the given value (or promised value), some\n * milliseconds after it resolved. Passes rejections immediately.\n * @param {Any*} promise\n * @param {Number} milliseconds\n * @returns a promise for the resolution of the given promise after milliseconds\n * time has elapsed since the resolution of the given promise.\n * If the given promise rejects, that is passed immediately.\n */\nPromise.prototype.delay = function Promise_delay(ms) {\n    return this.then(function Promise_delay_fulfilled(value) {\n        var deferred = defer();\n        deferred.setEstimate(Date.now() + ms);\n        setTimeout(function Promise_delay_task() {\n            deferred.resolve(value);\n        }, ms);\n        return deferred.promise;\n    }, null, ms);\n};\n\n/**\n * TODO\n */\nPromise.prototype.pull = function Promise_pull() {\n    return this.dispatch(\"pull\", []);\n};\n\n/**\n * TODO\n */\nPromise.prototype.pass = function Promise_pass() {\n    if (!this.toBePassed()) {\n        return new Promise(new Passed(this));\n    } else {\n        return this;\n    }\n};\n\n\n// Thus begins the portion dedicated to the deferred\n\nvar promises = new WeakMap();\n\nfunction Deferred(promise) {\n    this.promise = promise;\n    // A deferred has an intrinsic promise, denoted by its hidden handler\n    // property.  The promise property of the deferred may be assigned to a\n    // different promise (as it is in a Queue), but the intrinsic promise does\n    // not change.\n    promises.set(this, promise);\n    var self = this;\n    var resolve = this.resolve;\n    this.resolve = function (value) {\n        resolve.call(self, value);\n    };\n    var reject = this.reject;\n    this.reject = function (error) {\n        reject.call(self, error);\n    };\n}\n\n/**\n * TODO\n */\nDeferred.prototype.resolve = function Deferred_resolve(value) {\n    var handler = Q_getHandler(promises.get(this));\n    if (!handler.messages) {\n        return;\n    }\n    handler.become(Q(value));\n};\n\n/**\n * TODO\n */\nDeferred.prototype.reject = function Deferred_reject(reason) {\n    var handler = Q_getHandler(promises.get(this));\n    if (!handler.messages) {\n        return;\n    }\n    handler.become(Q_reject(reason));\n};\n\n/**\n * TODO\n */\nDeferred.prototype.setEstimate = function Deferred_setEstimate(estimate) {\n    estimate = +estimate;\n    if (estimate !== estimate) {\n        estimate = Infinity;\n    }\n    if (estimate < 1e12 && estimate !== -Infinity) {\n        throw new Error(\"Estimate values should be a number of miliseconds in the future\");\n    }\n    var handler = Q_getHandler(promises.get(this));\n    // TODO There is a bit of capability leakage going on here. The Deferred\n    // should only be able to set the estimate for its original\n    // Pending, not for any handler that promise subsequently became.\n    if (handler.setEstimate) {\n        handler.setEstimate(estimate);\n    }\n};\n\n// Thus ends the public interface\n\n// Thus begins the portion dedicated to handlers\n\nfunction Fulfilled(value) {\n    this.value = value;\n    this.estimate = Date.now();\n}\n\nFulfilled.prototype.state = \"fulfilled\";\n\nFulfilled.prototype.inspect = function Fulfilled_inspect() {\n    return {state: \"fulfilled\", value: this.value};\n};\n\nFulfilled.prototype.dispatch = function Fulfilled_dispatch(\n    resolve, op, operands\n) {\n    var result;\n    if (\n        op === \"then\" ||\n        op === \"get\" ||\n        op === \"call\" ||\n        op === \"invoke\" ||\n        op === \"keys\" ||\n        op === \"iterate\" ||\n        op === \"pull\"\n    ) {\n        try {\n            result = this[op].apply(this, operands);\n        } catch (exception) {\n            result = Q_reject(exception);\n        }\n    } else if (op === \"estimate\") {\n        operands[0].call(void 0, this.estimate);\n    } else {\n        var error = new Error(\n            \"Fulfilled promises do not support the \" + op + \" operator\"\n        );\n        result = Q_reject(error);\n    }\n    if (resolve) {\n        resolve(result);\n    }\n};\n\nFulfilled.prototype.then = function Fulfilled_then() {\n    return this.value;\n};\n\nFulfilled.prototype.get = function Fulfilled_get(name) {\n    return this.value[name];\n};\n\nFulfilled.prototype.call = function Fulfilled_call(args, thisp) {\n    return this.callInvoke(this.value, args, thisp);\n};\n\nFulfilled.prototype.invoke = function Fulfilled_invoke(name, args) {\n    return this.callInvoke(this.value[name], args, this.value);\n};\n\nFulfilled.prototype.callInvoke = function Fulfilled_callInvoke(callback, args, thisp) {\n    var waitToBePassed;\n    for (var index = 0; index < args.length; index++) {\n        if (Q_isPromise(args[index]) && args[index].toBePassed()) {\n            waitToBePassed = waitToBePassed || [];\n            waitToBePassed.push(args[index]);\n        }\n    }\n    if (waitToBePassed) {\n        var self = this;\n        return Q_all(waitToBePassed).then(function () {\n            return self.callInvoke(callback, args.map(function (arg) {\n                if (Q_isPromise(arg) && arg.toBePassed()) {\n                    return arg.inspect().value;\n                } else {\n                    return arg;\n                }\n            }), thisp);\n        });\n    } else {\n        return callback.apply(thisp, args);\n    }\n};\n\nFulfilled.prototype.keys = function Fulfilled_keys() {\n    return Object.keys(this.value);\n};\n\nFulfilled.prototype.iterate = function Fulfilled_iterate() {\n    return iterate(this.value);\n};\n\nFulfilled.prototype.pull = function Fulfilled_pull() {\n    var result;\n    if (Object(this.value) === this.value) {\n        result = Array.isArray(this.value) ? [] : {};\n        for (var name in this.value) {\n            result[name] = this.value[name];\n        }\n    } else {\n        result = this.value;\n    }\n    return Q.push(result);\n};\n\n\nfunction Rejected(reason) {\n    this.reason = reason;\n    this.estimate = Infinity;\n}\n\nRejected.prototype.state = \"rejected\";\n\nRejected.prototype.inspect = function Rejected_inspect() {\n    return {state: \"rejected\", reason: this.reason};\n};\n\nRejected.prototype.dispatch = function Rejected_dispatch(\n    resolve, op, operands\n) {\n    var result;\n    if (op === \"then\") {\n        result = this.then(resolve, operands[0]);\n    } else {\n        result = this;\n    }\n    if (resolve) {\n        resolve(result);\n    }\n};\n\nRejected.prototype.then = function Rejected_then(\n    resolve, rejected\n) {\n    return rejected ? rejected(this.reason) : this;\n};\n\n\nfunction Pending() {\n    // if \"messages\" is an \"Array\", that indicates that the promise has not yet\n    // been resolved.  If it is \"undefined\", it has been resolved.  Each\n    // element of the messages array is itself an array of complete arguments to\n    // forward to the resolved promise.  We coerce the resolution value to a\n    // promise using the `resolve` function because it handles both fully\n    // non-thenable values and other thenables gracefully.\n    this.messages = [];\n    this.observers = [];\n    this.estimate = Infinity;\n}\n\nPending.prototype.state = \"pending\";\n\nPending.prototype.inspect = function Pending_inspect() {\n    return {state: \"pending\"};\n};\n\nPending.prototype.dispatch = function Pending_dispatch(resolve, op, operands) {\n    this.messages.push([resolve, op, operands]);\n    if (op === \"estimate\") {\n        this.observers.push(operands[0]);\n        var self = this;\n        asap(function Pending_dispatch_task() {\n            operands[0].call(void 0, self.estimate);\n        });\n    }\n};\n\nPending.prototype.become = function Pending_become(promise) {\n    this.became = theViciousCycle;\n    var handler = Q_getHandler(promise);\n    this.became = handler;\n\n    handlers.set(promise, handler);\n    this.promise = void 0;\n\n    this.messages.forEach(function Pending_become_eachMessage(message) {\n        // makeQ does not have this asap call, so it must be queueing events\n        // downstream. TODO look at makeQ to ascertain\n        asap(function Pending_become_eachMessage_task() {\n            var handler = Q_getHandler(promise);\n            handler.dispatch.apply(handler, message);\n        });\n    });\n\n    this.messages = void 0;\n    this.observers = void 0;\n};\n\nPending.prototype.setEstimate = function Pending_setEstimate(estimate) {\n    if (this.observers) {\n        var self = this;\n        self.estimate = estimate;\n        this.observers.forEach(function Pending_eachObserver(observer) {\n            asap(function Pending_setEstimate_eachObserver_task() {\n                observer.call(void 0, estimate);\n            });\n        });\n    }\n};\n\nfunction Thenable(thenable) {\n    this.thenable = thenable;\n    this.became = null;\n    this.estimate = Infinity;\n}\n\nThenable.prototype.state = \"thenable\";\n\nThenable.prototype.inspect = function Thenable_inspect() {\n    return {state: \"pending\"};\n};\n\nThenable.prototype.cast = function Thenable_cast() {\n    if (!this.became) {\n        var deferred = defer();\n        var thenable = this.thenable;\n        asap(function Thenable_cast_task() {\n            try {\n                thenable.then(deferred.resolve, deferred.reject);\n            } catch (exception) {\n                deferred.reject(exception);\n            }\n        });\n        this.became = Q_getHandler(deferred.promise);\n    }\n    return this.became;\n};\n\nThenable.prototype.dispatch = function Thenable_dispatch(resolve, op, args) {\n    this.cast().dispatch(resolve, op, args);\n};\n\n\nfunction Passed(promise) {\n    this.promise = promise;\n}\n\nPassed.prototype.state = \"passed\";\n\nPassed.prototype.inspect = function Passed_inspect() {\n    return this.promise.inspect();\n};\n\nPassed.prototype.dispatch = function Passed_dispatch(resolve, op, args) {\n    return this.promise.rawDispatch(resolve, op, args);\n};\n\n\n// Thus begins the Q Node.js bridge\n\n/**\n * Calls a method of a Node-style object that accepts a Node-style\n * callback, forwarding the given variadic arguments, plus a provided\n * callback argument.\n * @param object an object that has the named method\n * @param {String} name name of the method of object\n * @param ...args arguments to pass to the method; the callback will\n * be provided by Q and appended to these arguments.\n * @returns a promise for the value or error\n */\nQ.ninvoke = function Q_ninvoke(object, name /*...args*/) {\n    var args = new Array(Math.max(0, arguments.length - 1));\n    for (var index = 2; index < arguments.length; index++) {\n        args[index - 2] = arguments[index];\n    }\n    var deferred = Q.defer();\n    args[index - 2] = deferred.makeNodeResolver();\n    Q(object).dispatch(\"invoke\", [name, args]).catch(deferred.reject);\n    return deferred.promise;\n};\n\nPromise.prototype.ninvoke = function Promise_ninvoke(name /*...args*/) {\n    var args = new Array(arguments.length);\n    for (var index = 1; index < arguments.length; index++) {\n        args[index - 1] = arguments[index];\n    }\n    var deferred = Q.defer();\n    args[index - 1] = deferred.makeNodeResolver();\n    this.dispatch(\"invoke\", [name, args]).catch(deferred.reject);\n    return deferred.promise;\n};\n\n/**\n * Wraps a Node.js continuation passing function and returns an equivalent\n * version that returns a promise.\n * @example\n * Q.denodeify(FS.readFile)(__filename, \"utf-8\")\n * .then(console.log)\n * .done()\n */\nQ.denodeify = function Q_denodeify(callback, pattern) {\n    return function denodeified() {\n        var args = new Array(arguments.length + 1);\n        var index = 0;\n        for (; index < arguments.length; index++) {\n            args[index] = arguments[index];\n        }\n        var deferred = Q.defer();\n        args[index] = deferred.makeNodeResolver(pattern);\n        Q(callback).apply(this, args).catch(deferred.reject);\n        return deferred.promise;\n    };\n};\n\n/**\n * Creates a Node.js-style callback that will resolve or reject the deferred\n * promise.\n * @param unpack `true` means that the Node.js-style-callback accepts a\n * fixed or variable number of arguments and that the deferred should be resolved\n * with an array of these value arguments, or rejected with the error argument.\n * An array of names means that the Node.js-style-callback accepts a fixed\n * number of arguments, and that the resolution should be an object with\n * properties corresponding to the given names and respective value arguments.\n * @returns a nodeback\n */\nDeferred.prototype.makeNodeResolver = function (unpack) {\n    var resolve = this.resolve;\n    if (unpack === true) {\n        return function variadicNodebackToResolver(error) {\n            if (error) {\n                resolve(Q_reject(error));\n            } else {\n                var value = new Array(Math.max(0, arguments.length - 1));\n                for (var index = 1; index < arguments.length; index++) {\n                    value[index - 1] = arguments[index];\n                }\n                resolve(value);\n            }\n        };\n    } else if (unpack) {\n        return function namedArgumentNodebackToResolver(error) {\n            if (error) {\n                resolve(Q_reject(error));\n            } else {\n                var value = {};\n                for (var index = 0; index < unpack.length; index++) {\n                    value[unpack[index]] = arguments[index + 1];\n                }\n                resolve(value);\n            }\n        };\n    } else {\n        return function nodebackToResolver(error, value) {\n            if (error) {\n                resolve(Q_reject(error));\n            } else {\n                resolve(value);\n            }\n        };\n    }\n};\n\n/**\n * TODO\n */\nPromise.prototype.nodeify = function Promise_nodeify(nodeback) {\n    if (nodeback) {\n        this.done(function (value) {\n            nodeback(null, value);\n        }, nodeback);\n    } else {\n        return this;\n    }\n};\n\n\n// DEPRECATED\n\nQ.nextTick = deprecate(asap, \"nextTick\", \"asap package\");\n\nQ.resolve = deprecate(Q, \"resolve\", \"Q\");\n\nQ.fulfill = deprecate(Q, \"fulfill\", \"Q\");\n\nQ.isPromiseAlike = deprecate(isThenable, \"isPromiseAlike\", \"(not supported)\");\n\nQ.fail = deprecate(function (value, rejected) {\n    return Q(value).catch(rejected);\n}, \"Q.fail\", \"Q(value).catch\");\n\nQ.fin = deprecate(function (value, regardless) {\n    return Q(value).finally(regardless);\n}, \"Q.fin\", \"Q(value).finally\");\n\nQ.progress = deprecate(function (value) {\n    return value;\n}, \"Q.progress\", \"no longer supported\");\n\nQ.thenResolve = deprecate(function (promise, value) {\n    return Q(promise).thenResolve(value);\n}, \"thenResolve\", \"Q(value).thenResolve\");\n\nQ.thenReject = deprecate(function (promise, reason) {\n    return Q(promise).thenResolve(reason);\n}, \"thenResolve\", \"Q(value).thenResolve\");\n\nQ.isPending = deprecate(function (value) {\n    return Q(value).isPending();\n}, \"isPending\", \"Q(value).isPending\");\n\nQ.isFulfilled = deprecate(function (value) {\n    return Q(value).isFulfilled();\n}, \"isFulfilled\", \"Q(value).isFulfilled\");\n\nQ.isRejected = deprecate(function (value) {\n    return Q(value).isRejected();\n}, \"isRejected\", \"Q(value).isRejected\");\n\nQ.master = deprecate(function (value) {\n    return value;\n}, \"master\", \"no longer necessary\");\n\nQ.makePromise = function () {\n    throw new Error(\"makePromise is no longer supported\");\n};\n\nQ.dispatch = deprecate(function (value, op, operands) {\n    return Q(value).dispatch(op, operands);\n}, \"dispatch\", \"Q(value).dispatch\");\n\nQ.get = deprecate(function (object, name) {\n    return Q(object).get(name);\n}, \"get\", \"Q(value).get\");\n\nQ.keys = deprecate(function (object) {\n    return Q(object).keys();\n}, \"keys\", \"Q(value).keys\");\n\nQ.post = deprecate(function (object, name, args) {\n    return Q(object).post(name, args);\n}, \"post\", \"Q(value).invoke (spread arguments)\");\n\nQ.mapply = deprecate(function (object, name, args) {\n    return Q(object).post(name, args);\n}, \"post\", \"Q(value).invoke (spread arguments)\");\n\nQ.send = deprecate(function (object, name) {\n    return Q(object).post(name, Array.prototype.slice.call(arguments, 2));\n}, \"send\", \"Q(value).invoke\");\n\nQ.set = function () {\n    throw new Error(\"Q.set no longer supported\");\n};\n\nQ.delete = function () {\n    throw new Error(\"Q.delete no longer supported\");\n};\n\nQ.nearer = deprecate(function (value) {\n    if (Q_isPromise(value) && value.isFulfilled()) {\n        return value.inspect().value;\n    } else {\n        return value;\n    }\n}, \"nearer\", \"inspect().value (+nuances)\");\n\nQ.fapply = deprecate(function (callback, args) {\n    return Q(callback).dispatch(\"call\", [args]);\n}, \"fapply\", \"Q(callback).apply(thisp, args)\");\n\nQ.fcall = deprecate(function (callback /*, ...args*/) {\n    return Q(callback).dispatch(\"call\", [Array.prototype.slice.call(arguments, 1)]);\n}, \"fcall\", \"Q(callback).call(thisp, ...args)\");\n\nQ.fbind = deprecate(function (object /*...args*/) {\n    var promise = Q(object);\n    var args = Array.prototype.slice.call(arguments, 1);\n    return function fbound() {\n        return promise.dispatch(\"call\", [\n            args.concat(Array.prototype.slice.call(arguments)),\n            this\n        ]);\n    };\n}, \"fbind\", \"bind with thisp\");\n\nQ.promise = deprecate(Promise, \"promise\", \"Promise\");\n\nPromise.prototype.fapply = deprecate(function (args) {\n    return this.dispatch(\"call\", [args]);\n}, \"fapply\", \"apply with thisp\");\n\nPromise.prototype.fcall = deprecate(function (/*...args*/) {\n    return this.dispatch(\"call\", [Array.prototype.slice.call(arguments)]);\n}, \"fcall\", \"try or call with thisp\");\n\nPromise.prototype.fail = deprecate(function (rejected) {\n    return this.catch(rejected);\n}, \"fail\", \"catch\");\n\nPromise.prototype.fin = deprecate(function (regardless) {\n    return this.finally(regardless);\n}, \"fin\", \"finally\");\n\nPromise.prototype.set = function () {\n    throw new Error(\"Promise set no longer supported\");\n};\n\nPromise.prototype.delete = function () {\n    throw new Error(\"Promise delete no longer supported\");\n};\n\nDeferred.prototype.notify = deprecate(function () {\n}, \"notify\", \"no longer supported\");\n\nPromise.prototype.progress = deprecate(function () {\n    return this;\n}, \"progress\", \"no longer supported\");\n\n// alternative proposed by Redsandro, dropped in favor of post to streamline\n// the interface\nPromise.prototype.mapply = deprecate(function (name, args) {\n    return this.dispatch(\"invoke\", [name, args]);\n}, \"mapply\", \"invoke\");\n\nPromise.prototype.fbind = deprecate(function () {\n    return Q.fbind.apply(Q, [void 0].concat(Array.prototype.slice.call(arguments)));\n}, \"fbind\", \"bind(thisp, ...args)\");\n\n// alternative proposed by Mark Miller, dropped in favor of invoke\nPromise.prototype.send = deprecate(function () {\n    return this.dispatch(\"invoke\", [name, Array.prototype.slice.call(arguments, 1)]);\n}, \"send\", \"invoke\");\n\n// alternative proposed by Redsandro, dropped in favor of invoke\nPromise.prototype.mcall = deprecate(function () {\n    return this.dispatch(\"invoke\", [name, Array.prototype.slice.call(arguments, 1)]);\n}, \"mcall\", \"invoke\");\n\nPromise.prototype.passByCopy = deprecate(function (value) {\n    return value;\n}, \"passByCopy\", \"Q.passByCopy\");\n\n// Deprecated Node.js bridge promise methods\n\nQ.nfapply = deprecate(function (callback, args) {\n    var deferred = Q.defer();\n    var nodeArgs = Array.prototype.slice.call(args);\n    nodeArgs.push(deferred.makeNodeResolver());\n    Q(callback).apply(this, nodeArgs).catch(deferred.reject);\n    return deferred.promise;\n}, \"nfapply\");\n\nPromise.prototype.nfapply = deprecate(function (args) {\n    return Q.nfapply(this, args);\n}, \"nfapply\");\n\nQ.nfcall = deprecate(function (callback /*...args*/) {\n    var args = Array.prototype.slice.call(arguments, 1);\n    return Q.nfapply(callback, args);\n}, \"nfcall\");\n\nPromise.prototype.nfcall = deprecate(function () {\n    var args = new Array(arguments.length);\n    for (var index = 0; index < arguments.length; index++) {\n        args[index] = arguments[index];\n    }\n    return Q.nfapply(this, args);\n}, \"nfcall\");\n\nQ.nfbind = deprecate(function (callback /*...args*/) {\n    var baseArgs = Array.prototype.slice.call(arguments, 1);\n    return function () {\n        var nodeArgs = baseArgs.concat(Array.prototype.slice.call(arguments));\n        var deferred = Q.defer();\n        nodeArgs.push(deferred.makeNodeResolver());\n        Q(callback).apply(this, nodeArgs).catch(deferred.reject);\n        return deferred.promise;\n    };\n}, \"nfbind\", \"denodeify (with caveats)\");\n\nPromise.prototype.nfbind = deprecate(function () {\n    var args = new Array(arguments.length);\n    for (var index = 0; index < arguments.length; index++) {\n        args[index] = arguments[index];\n    }\n    return Q.nfbind(this, args);\n}, \"nfbind\", \"denodeify (with caveats)\");\n\nQ.nbind = deprecate(function (callback, thisp /*...args*/) {\n    var baseArgs = Array.prototype.slice.call(arguments, 2);\n    return function () {\n        var nodeArgs = baseArgs.concat(Array.prototype.slice.call(arguments));\n        var deferred = Q.defer();\n        nodeArgs.push(deferred.makeNodeResolver());\n        function bound() {\n            return callback.apply(thisp, arguments);\n        }\n        Q(bound).apply(this, nodeArgs).catch(deferred.reject);\n        return deferred.promise;\n    };\n}, \"nbind\", \"denodeify (with caveats)\");\n\nQ.npost = deprecate(function (object, name, nodeArgs) {\n    var deferred = Q.defer();\n    nodeArgs.push(deferred.makeNodeResolver());\n    Q(object).dispatch(\"invoke\", [name, nodeArgs]).catch(deferred.reject);\n    return deferred.promise;\n}, \"npost\", \"ninvoke (with spread arguments)\");\n\nPromise.prototype.npost = deprecate(function (name, args) {\n    return Q.npost(this, name, args);\n}, \"npost\", \"Q.ninvoke (with caveats)\");\n\nQ.nmapply = deprecate(Q.nmapply, \"nmapply\", \"q/node nmapply\");\nPromise.prototype.nmapply = deprecate(Promise.prototype.npost, \"nmapply\", \"Q.nmapply\");\n\nQ.nsend = deprecate(Q.ninvoke, \"nsend\", \"q/node ninvoke\");\nQ.nmcall = deprecate(Q.ninvoke, \"nmcall\", \"q/node ninvoke\");\nPromise.prototype.nsend = deprecate(Promise.prototype.ninvoke, \"nsend\", \"q/node ninvoke\");\nPromise.prototype.nmcall = deprecate(Promise.prototype.ninvoke, \"nmcall\", \"q/node ninvoke\");\n\n// All code before this point will be filtered from stack traces.\nvar qEndingLine = captureLine();\n\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}