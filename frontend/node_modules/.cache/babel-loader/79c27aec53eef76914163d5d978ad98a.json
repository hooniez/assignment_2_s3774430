{"ast":null,"code":"// Generated by CoffeeScript 2.4.1\n(function () {\n  var NodeType,\n      WriterState,\n      XMLAttribute,\n      XMLCData,\n      XMLComment,\n      XMLDTDAttList,\n      XMLDTDElement,\n      XMLDTDEntity,\n      XMLDTDNotation,\n      XMLDeclaration,\n      XMLDocType,\n      XMLDocument,\n      XMLDocumentCB,\n      XMLElement,\n      XMLProcessingInstruction,\n      XMLRaw,\n      XMLStringWriter,\n      XMLStringifier,\n      XMLText,\n      getValue,\n      isFunction,\n      isObject,\n      isPlainObject,\n      hasProp = {}.hasOwnProperty;\n  ({\n    isObject,\n    isFunction,\n    isPlainObject,\n    getValue\n  } = require('./Utility'));\n  NodeType = require('./NodeType');\n  XMLDocument = require('./XMLDocument');\n  XMLElement = require('./XMLElement');\n  XMLCData = require('./XMLCData');\n  XMLComment = require('./XMLComment');\n  XMLRaw = require('./XMLRaw');\n  XMLText = require('./XMLText');\n  XMLProcessingInstruction = require('./XMLProcessingInstruction');\n  XMLDeclaration = require('./XMLDeclaration');\n  XMLDocType = require('./XMLDocType');\n  XMLDTDAttList = require('./XMLDTDAttList');\n  XMLDTDEntity = require('./XMLDTDEntity');\n  XMLDTDElement = require('./XMLDTDElement');\n  XMLDTDNotation = require('./XMLDTDNotation');\n  XMLAttribute = require('./XMLAttribute');\n  XMLStringifier = require('./XMLStringifier');\n  XMLStringWriter = require('./XMLStringWriter');\n  WriterState = require('./WriterState'); // Represents an XML builder\n\n  module.exports = XMLDocumentCB = class XMLDocumentCB {\n    // Initializes a new instance of `XMLDocumentCB`\n    // `options.keepNullNodes` whether nodes with null values will be kept\n    //     or ignored: true or false\n    // `options.keepNullAttributes` whether attributes with null values will be\n    //     kept or ignored: true or false\n    // `options.ignoreDecorators` whether decorator strings will be ignored when\n    //     converting JS objects: true or false\n    // `options.separateArrayItems` whether array items are created as separate\n    //     nodes when passed as an object value: true or false\n    // `options.noDoubleEncoding` whether existing html entities are encoded:\n    //     true or false\n    // `options.stringify` a set of functions to use for converting values to\n    //     strings\n    // `options.writer` the default XML writer to use for converting nodes to\n    //     string. If the default writer is not set, the built-in XMLStringWriter\n    //     will be used instead.\n    // `onData` the function to be called when a new chunk of XML is output. The\n    //          string containing the XML chunk is passed to `onData` as its first\n    //          argument, and the current indentation level as its second argument.\n    // `onEnd`  the function to be called when the XML document is completed with\n    //          `end`. `onEnd` does not receive any arguments.\n    constructor(options, onData, onEnd) {\n      var writerOptions;\n      this.name = \"?xml\";\n      this.type = NodeType.Document;\n      options || (options = {});\n      writerOptions = {};\n\n      if (!options.writer) {\n        options.writer = new XMLStringWriter();\n      } else if (isPlainObject(options.writer)) {\n        writerOptions = options.writer;\n        options.writer = new XMLStringWriter();\n      }\n\n      this.options = options;\n      this.writer = options.writer;\n      this.writerOptions = this.writer.filterOptions(writerOptions);\n      this.stringify = new XMLStringifier(options);\n\n      this.onDataCallback = onData || function () {};\n\n      this.onEndCallback = onEnd || function () {};\n\n      this.currentNode = null;\n      this.currentLevel = -1;\n      this.openTags = {};\n      this.documentStarted = false;\n      this.documentCompleted = false;\n      this.root = null;\n    } // Creates a child element node from the given XMLNode\n    // `node` the child node\n\n\n    createChildNode(node) {\n      var att, attName, attributes, child, i, len, ref, ref1;\n\n      switch (node.type) {\n        case NodeType.CData:\n          this.cdata(node.value);\n          break;\n\n        case NodeType.Comment:\n          this.comment(node.value);\n          break;\n\n        case NodeType.Element:\n          attributes = {};\n          ref = node.attribs;\n\n          for (attName in ref) {\n            if (!hasProp.call(ref, attName)) continue;\n            att = ref[attName];\n            attributes[attName] = att.value;\n          }\n\n          this.node(node.name, attributes);\n          break;\n\n        case NodeType.Dummy:\n          this.dummy();\n          break;\n\n        case NodeType.Raw:\n          this.raw(node.value);\n          break;\n\n        case NodeType.Text:\n          this.text(node.value);\n          break;\n\n        case NodeType.ProcessingInstruction:\n          this.instruction(node.target, node.value);\n          break;\n\n        default:\n          throw new Error(\"This XML node type is not supported in a JS object: \" + node.constructor.name);\n      }\n\n      ref1 = node.children; // write child nodes recursively\n\n      for (i = 0, len = ref1.length; i < len; i++) {\n        child = ref1[i];\n        this.createChildNode(child);\n\n        if (child.type === NodeType.Element) {\n          this.up();\n        }\n      }\n\n      return this;\n    } // Creates a dummy node\n\n\n    dummy() {\n      // no-op, just return this\n      return this;\n    } // Creates a node\n    // `name` name of the node\n    // `attributes` an object containing name/value pairs of attributes\n    // `text` element text\n\n\n    node(name, attributes, text) {\n      if (name == null) {\n        throw new Error(\"Missing node name.\");\n      }\n\n      if (this.root && this.currentLevel === -1) {\n        throw new Error(\"Document can only have one root node. \" + this.debugInfo(name));\n      }\n\n      this.openCurrent();\n      name = getValue(name);\n\n      if (attributes == null) {\n        attributes = {};\n      }\n\n      attributes = getValue(attributes); // swap argument order: text <-> attributes\n\n      if (!isObject(attributes)) {\n        [text, attributes] = [attributes, text];\n      }\n\n      this.currentNode = new XMLElement(this, name, attributes);\n      this.currentNode.children = false;\n      this.currentLevel++;\n      this.openTags[this.currentLevel] = this.currentNode;\n\n      if (text != null) {\n        this.text(text);\n      }\n\n      return this;\n    } // Creates a child element node or an element type declaration when called\n    // inside the DTD\n    // `name` name of the node\n    // `attributes` an object containing name/value pairs of attributes\n    // `text` element text\n\n\n    element(name, attributes, text) {\n      var child, i, len, oldValidationFlag, ref, root;\n\n      if (this.currentNode && this.currentNode.type === NodeType.DocType) {\n        this.dtdElement(...arguments);\n      } else {\n        if (Array.isArray(name) || isObject(name) || isFunction(name)) {\n          oldValidationFlag = this.options.noValidation;\n          this.options.noValidation = true;\n          root = new XMLDocument(this.options).element('TEMP_ROOT');\n          root.element(name);\n          this.options.noValidation = oldValidationFlag;\n          ref = root.children;\n\n          for (i = 0, len = ref.length; i < len; i++) {\n            child = ref[i];\n            this.createChildNode(child);\n\n            if (child.type === NodeType.Element) {\n              this.up();\n            }\n          }\n        } else {\n          this.node(name, attributes, text);\n        }\n      }\n\n      return this;\n    } // Adds or modifies an attribute\n    // `name` attribute name\n    // `value` attribute value\n\n\n    attribute(name, value) {\n      var attName, attValue;\n\n      if (!this.currentNode || this.currentNode.children) {\n        throw new Error(\"att() can only be used immediately after an ele() call in callback mode. \" + this.debugInfo(name));\n      }\n\n      if (name != null) {\n        name = getValue(name);\n      }\n\n      if (isObject(name)) {\n        // expand if object\n        for (attName in name) {\n          if (!hasProp.call(name, attName)) continue;\n          attValue = name[attName];\n          this.attribute(attName, attValue);\n        }\n      } else {\n        if (isFunction(value)) {\n          value = value.apply();\n        }\n\n        if (this.options.keepNullAttributes && value == null) {\n          this.currentNode.attribs[name] = new XMLAttribute(this, name, \"\");\n        } else if (value != null) {\n          this.currentNode.attribs[name] = new XMLAttribute(this, name, value);\n        }\n      }\n\n      return this;\n    } // Creates a text node\n    // `value` element text\n\n\n    text(value) {\n      var node;\n      this.openCurrent();\n      node = new XMLText(this, value);\n      this.onData(this.writer.text(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);\n      return this;\n    } // Creates a CDATA node\n    // `value` element text without CDATA delimiters\n\n\n    cdata(value) {\n      var node;\n      this.openCurrent();\n      node = new XMLCData(this, value);\n      this.onData(this.writer.cdata(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);\n      return this;\n    } // Creates a comment node\n    // `value` comment text\n\n\n    comment(value) {\n      var node;\n      this.openCurrent();\n      node = new XMLComment(this, value);\n      this.onData(this.writer.comment(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);\n      return this;\n    } // Adds unescaped raw text\n    // `value` text\n\n\n    raw(value) {\n      var node;\n      this.openCurrent();\n      node = new XMLRaw(this, value);\n      this.onData(this.writer.raw(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);\n      return this;\n    } // Adds a processing instruction\n    // `target` instruction target\n    // `value` instruction value\n\n\n    instruction(target, value) {\n      var i, insTarget, insValue, len, node;\n      this.openCurrent();\n\n      if (target != null) {\n        target = getValue(target);\n      }\n\n      if (value != null) {\n        value = getValue(value);\n      }\n\n      if (Array.isArray(target)) {\n        // expand if array\n        for (i = 0, len = target.length; i < len; i++) {\n          insTarget = target[i];\n          this.instruction(insTarget);\n        }\n      } else if (isObject(target)) {\n        // expand if object\n        for (insTarget in target) {\n          if (!hasProp.call(target, insTarget)) continue;\n          insValue = target[insTarget];\n          this.instruction(insTarget, insValue);\n        }\n      } else {\n        if (isFunction(value)) {\n          value = value.apply();\n        }\n\n        node = new XMLProcessingInstruction(this, target, value);\n        this.onData(this.writer.processingInstruction(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);\n      }\n\n      return this;\n    } // Creates the xml declaration\n    // `version` A version number string, e.g. 1.0\n    // `encoding` Encoding declaration, e.g. UTF-8\n    // `standalone` standalone document declaration: true or false\n\n\n    declaration(version, encoding, standalone) {\n      var node;\n      this.openCurrent();\n\n      if (this.documentStarted) {\n        throw new Error(\"declaration() must be the first node.\");\n      }\n\n      node = new XMLDeclaration(this, version, encoding, standalone);\n      this.onData(this.writer.declaration(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);\n      return this;\n    } // Creates the document type declaration\n    // `root`  the name of the root node\n    // `pubID` the public identifier of the external subset\n    // `sysID` the system identifier of the external subset\n\n\n    doctype(root, pubID, sysID) {\n      this.openCurrent();\n\n      if (root == null) {\n        throw new Error(\"Missing root node name.\");\n      }\n\n      if (this.root) {\n        throw new Error(\"dtd() must come before the root node.\");\n      }\n\n      this.currentNode = new XMLDocType(this, pubID, sysID);\n      this.currentNode.rootNodeName = root;\n      this.currentNode.children = false;\n      this.currentLevel++;\n      this.openTags[this.currentLevel] = this.currentNode;\n      return this;\n    } // Creates an element type declaration\n    // `name` element name\n    // `value` element content (defaults to #PCDATA)\n\n\n    dtdElement(name, value) {\n      var node;\n      this.openCurrent();\n      node = new XMLDTDElement(this, name, value);\n      this.onData(this.writer.dtdElement(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);\n      return this;\n    } // Creates an attribute declaration\n    // `elementName` the name of the element containing this attribute\n    // `attributeName` attribute name\n    // `attributeType` type of the attribute (defaults to CDATA)\n    // `defaultValueType` default value type (either #REQUIRED, #IMPLIED, #FIXED or\n    //                    #DEFAULT) (defaults to #IMPLIED)\n    // `defaultValue` default value of the attribute\n    //                (only used for #FIXED or #DEFAULT)\n\n\n    attList(elementName, attributeName, attributeType, defaultValueType, defaultValue) {\n      var node;\n      this.openCurrent();\n      node = new XMLDTDAttList(this, elementName, attributeName, attributeType, defaultValueType, defaultValue);\n      this.onData(this.writer.dtdAttList(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);\n      return this;\n    } // Creates a general entity declaration\n    // `name` the name of the entity\n    // `value` internal entity value or an object with external entity details\n    // `value.pubID` public identifier\n    // `value.sysID` system identifier\n    // `value.nData` notation declaration\n\n\n    entity(name, value) {\n      var node;\n      this.openCurrent();\n      node = new XMLDTDEntity(this, false, name, value);\n      this.onData(this.writer.dtdEntity(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);\n      return this;\n    } // Creates a parameter entity declaration\n    // `name` the name of the entity\n    // `value` internal entity value or an object with external entity details\n    // `value.pubID` public identifier\n    // `value.sysID` system identifier\n\n\n    pEntity(name, value) {\n      var node;\n      this.openCurrent();\n      node = new XMLDTDEntity(this, true, name, value);\n      this.onData(this.writer.dtdEntity(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);\n      return this;\n    } // Creates a NOTATION declaration\n    // `name` the name of the notation\n    // `value` an object with external entity details\n    // `value.pubID` public identifier\n    // `value.sysID` system identifier\n\n\n    notation(name, value) {\n      var node;\n      this.openCurrent();\n      node = new XMLDTDNotation(this, name, value);\n      this.onData(this.writer.dtdNotation(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);\n      return this;\n    } // Gets the parent node\n\n\n    up() {\n      if (this.currentLevel < 0) {\n        throw new Error(\"The document node has no parent.\");\n      }\n\n      if (this.currentNode) {\n        if (this.currentNode.children) {\n          this.closeNode(this.currentNode);\n        } else {\n          this.openNode(this.currentNode);\n        }\n\n        this.currentNode = null;\n      } else {\n        this.closeNode(this.openTags[this.currentLevel]);\n      }\n\n      delete this.openTags[this.currentLevel];\n      this.currentLevel--;\n      return this;\n    } // Ends the document\n\n\n    end() {\n      while (this.currentLevel >= 0) {\n        this.up();\n      }\n\n      return this.onEnd();\n    } // Opens the current parent node\n\n\n    openCurrent() {\n      if (this.currentNode) {\n        this.currentNode.children = true;\n        return this.openNode(this.currentNode);\n      }\n    } // Writes the opening tag of the current node or the entire node if it has\n    // no child nodes\n\n\n    openNode(node) {\n      var att, chunk, name, ref;\n\n      if (!node.isOpen) {\n        if (!this.root && this.currentLevel === 0 && node.type === NodeType.Element) {\n          this.root = node;\n        }\n\n        chunk = '';\n\n        if (node.type === NodeType.Element) {\n          this.writerOptions.state = WriterState.OpenTag;\n          chunk = this.writer.indent(node, this.writerOptions, this.currentLevel) + '<' + node.name;\n          ref = node.attribs;\n\n          for (name in ref) {\n            if (!hasProp.call(ref, name)) continue;\n            att = ref[name];\n            chunk += this.writer.attribute(att, this.writerOptions, this.currentLevel);\n          }\n\n          chunk += (node.children ? '>' : '/>') + this.writer.endline(node, this.writerOptions, this.currentLevel);\n          this.writerOptions.state = WriterState.InsideTag; // if node.type is NodeType.DocType\n        } else {\n          this.writerOptions.state = WriterState.OpenTag;\n          chunk = this.writer.indent(node, this.writerOptions, this.currentLevel) + '<!DOCTYPE ' + node.rootNodeName; // external identifier\n\n          if (node.pubID && node.sysID) {\n            chunk += ' PUBLIC \"' + node.pubID + '\" \"' + node.sysID + '\"';\n          } else if (node.sysID) {\n            chunk += ' SYSTEM \"' + node.sysID + '\"';\n          } // internal subset\n\n\n          if (node.children) {\n            chunk += ' [';\n            this.writerOptions.state = WriterState.InsideTag;\n          } else {\n            this.writerOptions.state = WriterState.CloseTag;\n            chunk += '>';\n          }\n\n          chunk += this.writer.endline(node, this.writerOptions, this.currentLevel);\n        }\n\n        this.onData(chunk, this.currentLevel);\n        return node.isOpen = true;\n      }\n    } // Writes the closing tag of the current node\n\n\n    closeNode(node) {\n      var chunk;\n\n      if (!node.isClosed) {\n        chunk = '';\n        this.writerOptions.state = WriterState.CloseTag;\n\n        if (node.type === NodeType.Element) {\n          chunk = this.writer.indent(node, this.writerOptions, this.currentLevel) + '</' + node.name + '>' + this.writer.endline(node, this.writerOptions, this.currentLevel); // if node.type is NodeType.DocType\n        } else {\n          chunk = this.writer.indent(node, this.writerOptions, this.currentLevel) + ']>' + this.writer.endline(node, this.writerOptions, this.currentLevel);\n        }\n\n        this.writerOptions.state = WriterState.None;\n        this.onData(chunk, this.currentLevel);\n        return node.isClosed = true;\n      }\n    } // Called when a new chunk of XML is output\n    // `chunk` a string containing the XML chunk\n    // `level` current indentation level\n\n\n    onData(chunk, level) {\n      this.documentStarted = true;\n      return this.onDataCallback(chunk, level + 1);\n    } // Called when the XML document is completed\n\n\n    onEnd() {\n      this.documentCompleted = true;\n      return this.onEndCallback();\n    } // Returns debug string\n\n\n    debugInfo(name) {\n      if (name == null) {\n        return \"\";\n      } else {\n        return \"node: <\" + name + \">\";\n      }\n    } // Node aliases\n\n\n    ele() {\n      return this.element(...arguments);\n    }\n\n    nod(name, attributes, text) {\n      return this.node(name, attributes, text);\n    }\n\n    txt(value) {\n      return this.text(value);\n    }\n\n    dat(value) {\n      return this.cdata(value);\n    }\n\n    com(value) {\n      return this.comment(value);\n    }\n\n    ins(target, value) {\n      return this.instruction(target, value);\n    }\n\n    dec(version, encoding, standalone) {\n      return this.declaration(version, encoding, standalone);\n    }\n\n    dtd(root, pubID, sysID) {\n      return this.doctype(root, pubID, sysID);\n    }\n\n    e(name, attributes, text) {\n      return this.element(name, attributes, text);\n    }\n\n    n(name, attributes, text) {\n      return this.node(name, attributes, text);\n    }\n\n    t(value) {\n      return this.text(value);\n    }\n\n    d(value) {\n      return this.cdata(value);\n    }\n\n    c(value) {\n      return this.comment(value);\n    }\n\n    r(value) {\n      return this.raw(value);\n    }\n\n    i(target, value) {\n      return this.instruction(target, value);\n    } // Attribute aliases\n\n\n    att() {\n      if (this.currentNode && this.currentNode.type === NodeType.DocType) {\n        return this.attList(...arguments);\n      } else {\n        return this.attribute(...arguments);\n      }\n    }\n\n    a() {\n      if (this.currentNode && this.currentNode.type === NodeType.DocType) {\n        return this.attList(...arguments);\n      } else {\n        return this.attribute(...arguments);\n      }\n    } // DTD aliases\n    // att() and ele() are defined above\n\n\n    ent(name, value) {\n      return this.entity(name, value);\n    }\n\n    pent(name, value) {\n      return this.pEntity(name, value);\n    }\n\n    not(name, value) {\n      return this.notation(name, value);\n    }\n\n  };\n}).call(this);","map":{"version":3,"names":["NodeType","WriterState","XMLAttribute","XMLCData","XMLComment","XMLDTDAttList","XMLDTDElement","XMLDTDEntity","XMLDTDNotation","XMLDeclaration","XMLDocType","XMLDocument","XMLDocumentCB","XMLElement","XMLProcessingInstruction","XMLRaw","XMLStringWriter","XMLStringifier","XMLText","getValue","isFunction","isObject","isPlainObject","hasProp","hasOwnProperty","require","module","exports","constructor","options","onData","onEnd","writerOptions","name","type","Document","writer","filterOptions","stringify","onDataCallback","onEndCallback","currentNode","currentLevel","openTags","documentStarted","documentCompleted","root","createChildNode","node","att","attName","attributes","child","i","len","ref","ref1","CData","cdata","value","Comment","comment","Element","attribs","call","Dummy","dummy","Raw","raw","Text","text","ProcessingInstruction","instruction","target","Error","children","length","up","debugInfo","openCurrent","element","oldValidationFlag","DocType","dtdElement","arguments","Array","isArray","noValidation","attribute","attValue","apply","keepNullAttributes","insTarget","insValue","processingInstruction","declaration","version","encoding","standalone","doctype","pubID","sysID","rootNodeName","attList","elementName","attributeName","attributeType","defaultValueType","defaultValue","dtdAttList","entity","dtdEntity","pEntity","notation","dtdNotation","closeNode","openNode","end","chunk","isOpen","state","OpenTag","indent","endline","InsideTag","CloseTag","isClosed","None","level","ele","nod","txt","dat","com","ins","dec","dtd","e","n","t","d","c","r","a","ent","pent","not"],"sources":["/Users/hooniesun/rmit/fwp/assessment1/lan/node_modules/xmlbuilder/lib/XMLDocumentCB.js"],"sourcesContent":["// Generated by CoffeeScript 2.4.1\n(function() {\n  var NodeType, WriterState, XMLAttribute, XMLCData, XMLComment, XMLDTDAttList, XMLDTDElement, XMLDTDEntity, XMLDTDNotation, XMLDeclaration, XMLDocType, XMLDocument, XMLDocumentCB, XMLElement, XMLProcessingInstruction, XMLRaw, XMLStringWriter, XMLStringifier, XMLText, getValue, isFunction, isObject, isPlainObject,\n    hasProp = {}.hasOwnProperty;\n\n  ({isObject, isFunction, isPlainObject, getValue} = require('./Utility'));\n\n  NodeType = require('./NodeType');\n\n  XMLDocument = require('./XMLDocument');\n\n  XMLElement = require('./XMLElement');\n\n  XMLCData = require('./XMLCData');\n\n  XMLComment = require('./XMLComment');\n\n  XMLRaw = require('./XMLRaw');\n\n  XMLText = require('./XMLText');\n\n  XMLProcessingInstruction = require('./XMLProcessingInstruction');\n\n  XMLDeclaration = require('./XMLDeclaration');\n\n  XMLDocType = require('./XMLDocType');\n\n  XMLDTDAttList = require('./XMLDTDAttList');\n\n  XMLDTDEntity = require('./XMLDTDEntity');\n\n  XMLDTDElement = require('./XMLDTDElement');\n\n  XMLDTDNotation = require('./XMLDTDNotation');\n\n  XMLAttribute = require('./XMLAttribute');\n\n  XMLStringifier = require('./XMLStringifier');\n\n  XMLStringWriter = require('./XMLStringWriter');\n\n  WriterState = require('./WriterState');\n\n  // Represents an XML builder\n  module.exports = XMLDocumentCB = class XMLDocumentCB {\n    // Initializes a new instance of `XMLDocumentCB`\n\n    // `options.keepNullNodes` whether nodes with null values will be kept\n    //     or ignored: true or false\n    // `options.keepNullAttributes` whether attributes with null values will be\n    //     kept or ignored: true or false\n    // `options.ignoreDecorators` whether decorator strings will be ignored when\n    //     converting JS objects: true or false\n    // `options.separateArrayItems` whether array items are created as separate\n    //     nodes when passed as an object value: true or false\n    // `options.noDoubleEncoding` whether existing html entities are encoded:\n    //     true or false\n    // `options.stringify` a set of functions to use for converting values to\n    //     strings\n    // `options.writer` the default XML writer to use for converting nodes to\n    //     string. If the default writer is not set, the built-in XMLStringWriter\n    //     will be used instead.\n\n    // `onData` the function to be called when a new chunk of XML is output. The\n    //          string containing the XML chunk is passed to `onData` as its first\n    //          argument, and the current indentation level as its second argument.\n    // `onEnd`  the function to be called when the XML document is completed with\n    //          `end`. `onEnd` does not receive any arguments.\n    constructor(options, onData, onEnd) {\n      var writerOptions;\n      this.name = \"?xml\";\n      this.type = NodeType.Document;\n      options || (options = {});\n      writerOptions = {};\n      if (!options.writer) {\n        options.writer = new XMLStringWriter();\n      } else if (isPlainObject(options.writer)) {\n        writerOptions = options.writer;\n        options.writer = new XMLStringWriter();\n      }\n      this.options = options;\n      this.writer = options.writer;\n      this.writerOptions = this.writer.filterOptions(writerOptions);\n      this.stringify = new XMLStringifier(options);\n      this.onDataCallback = onData || function() {};\n      this.onEndCallback = onEnd || function() {};\n      this.currentNode = null;\n      this.currentLevel = -1;\n      this.openTags = {};\n      this.documentStarted = false;\n      this.documentCompleted = false;\n      this.root = null;\n    }\n\n    // Creates a child element node from the given XMLNode\n\n    // `node` the child node\n    createChildNode(node) {\n      var att, attName, attributes, child, i, len, ref, ref1;\n      switch (node.type) {\n        case NodeType.CData:\n          this.cdata(node.value);\n          break;\n        case NodeType.Comment:\n          this.comment(node.value);\n          break;\n        case NodeType.Element:\n          attributes = {};\n          ref = node.attribs;\n          for (attName in ref) {\n            if (!hasProp.call(ref, attName)) continue;\n            att = ref[attName];\n            attributes[attName] = att.value;\n          }\n          this.node(node.name, attributes);\n          break;\n        case NodeType.Dummy:\n          this.dummy();\n          break;\n        case NodeType.Raw:\n          this.raw(node.value);\n          break;\n        case NodeType.Text:\n          this.text(node.value);\n          break;\n        case NodeType.ProcessingInstruction:\n          this.instruction(node.target, node.value);\n          break;\n        default:\n          throw new Error(\"This XML node type is not supported in a JS object: \" + node.constructor.name);\n      }\n      ref1 = node.children;\n      // write child nodes recursively\n      for (i = 0, len = ref1.length; i < len; i++) {\n        child = ref1[i];\n        this.createChildNode(child);\n        if (child.type === NodeType.Element) {\n          this.up();\n        }\n      }\n      return this;\n    }\n\n    // Creates a dummy node\n\n    dummy() {\n      // no-op, just return this\n      return this;\n    }\n\n    // Creates a node\n\n    // `name` name of the node\n    // `attributes` an object containing name/value pairs of attributes\n    // `text` element text\n    node(name, attributes, text) {\n      if (name == null) {\n        throw new Error(\"Missing node name.\");\n      }\n      if (this.root && this.currentLevel === -1) {\n        throw new Error(\"Document can only have one root node. \" + this.debugInfo(name));\n      }\n      this.openCurrent();\n      name = getValue(name);\n      if (attributes == null) {\n        attributes = {};\n      }\n      attributes = getValue(attributes);\n      // swap argument order: text <-> attributes\n      if (!isObject(attributes)) {\n        [text, attributes] = [attributes, text];\n      }\n      this.currentNode = new XMLElement(this, name, attributes);\n      this.currentNode.children = false;\n      this.currentLevel++;\n      this.openTags[this.currentLevel] = this.currentNode;\n      if (text != null) {\n        this.text(text);\n      }\n      return this;\n    }\n\n    // Creates a child element node or an element type declaration when called\n    // inside the DTD\n\n    // `name` name of the node\n    // `attributes` an object containing name/value pairs of attributes\n    // `text` element text\n    element(name, attributes, text) {\n      var child, i, len, oldValidationFlag, ref, root;\n      if (this.currentNode && this.currentNode.type === NodeType.DocType) {\n        this.dtdElement(...arguments);\n      } else {\n        if (Array.isArray(name) || isObject(name) || isFunction(name)) {\n          oldValidationFlag = this.options.noValidation;\n          this.options.noValidation = true;\n          root = new XMLDocument(this.options).element('TEMP_ROOT');\n          root.element(name);\n          this.options.noValidation = oldValidationFlag;\n          ref = root.children;\n          for (i = 0, len = ref.length; i < len; i++) {\n            child = ref[i];\n            this.createChildNode(child);\n            if (child.type === NodeType.Element) {\n              this.up();\n            }\n          }\n        } else {\n          this.node(name, attributes, text);\n        }\n      }\n      return this;\n    }\n\n    // Adds or modifies an attribute\n\n    // `name` attribute name\n    // `value` attribute value\n    attribute(name, value) {\n      var attName, attValue;\n      if (!this.currentNode || this.currentNode.children) {\n        throw new Error(\"att() can only be used immediately after an ele() call in callback mode. \" + this.debugInfo(name));\n      }\n      if (name != null) {\n        name = getValue(name);\n      }\n      if (isObject(name)) { // expand if object\n        for (attName in name) {\n          if (!hasProp.call(name, attName)) continue;\n          attValue = name[attName];\n          this.attribute(attName, attValue);\n        }\n      } else {\n        if (isFunction(value)) {\n          value = value.apply();\n        }\n        if (this.options.keepNullAttributes && (value == null)) {\n          this.currentNode.attribs[name] = new XMLAttribute(this, name, \"\");\n        } else if (value != null) {\n          this.currentNode.attribs[name] = new XMLAttribute(this, name, value);\n        }\n      }\n      return this;\n    }\n\n    // Creates a text node\n\n    // `value` element text\n    text(value) {\n      var node;\n      this.openCurrent();\n      node = new XMLText(this, value);\n      this.onData(this.writer.text(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);\n      return this;\n    }\n\n    // Creates a CDATA node\n\n    // `value` element text without CDATA delimiters\n    cdata(value) {\n      var node;\n      this.openCurrent();\n      node = new XMLCData(this, value);\n      this.onData(this.writer.cdata(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);\n      return this;\n    }\n\n    // Creates a comment node\n\n    // `value` comment text\n    comment(value) {\n      var node;\n      this.openCurrent();\n      node = new XMLComment(this, value);\n      this.onData(this.writer.comment(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);\n      return this;\n    }\n\n    // Adds unescaped raw text\n\n    // `value` text\n    raw(value) {\n      var node;\n      this.openCurrent();\n      node = new XMLRaw(this, value);\n      this.onData(this.writer.raw(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);\n      return this;\n    }\n\n    // Adds a processing instruction\n\n    // `target` instruction target\n    // `value` instruction value\n    instruction(target, value) {\n      var i, insTarget, insValue, len, node;\n      this.openCurrent();\n      if (target != null) {\n        target = getValue(target);\n      }\n      if (value != null) {\n        value = getValue(value);\n      }\n      if (Array.isArray(target)) { // expand if array\n        for (i = 0, len = target.length; i < len; i++) {\n          insTarget = target[i];\n          this.instruction(insTarget);\n        }\n      } else if (isObject(target)) { // expand if object\n        for (insTarget in target) {\n          if (!hasProp.call(target, insTarget)) continue;\n          insValue = target[insTarget];\n          this.instruction(insTarget, insValue);\n        }\n      } else {\n        if (isFunction(value)) {\n          value = value.apply();\n        }\n        node = new XMLProcessingInstruction(this, target, value);\n        this.onData(this.writer.processingInstruction(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);\n      }\n      return this;\n    }\n\n    // Creates the xml declaration\n\n    // `version` A version number string, e.g. 1.0\n    // `encoding` Encoding declaration, e.g. UTF-8\n    // `standalone` standalone document declaration: true or false\n    declaration(version, encoding, standalone) {\n      var node;\n      this.openCurrent();\n      if (this.documentStarted) {\n        throw new Error(\"declaration() must be the first node.\");\n      }\n      node = new XMLDeclaration(this, version, encoding, standalone);\n      this.onData(this.writer.declaration(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);\n      return this;\n    }\n\n    // Creates the document type declaration\n\n    // `root`  the name of the root node\n    // `pubID` the public identifier of the external subset\n    // `sysID` the system identifier of the external subset\n    doctype(root, pubID, sysID) {\n      this.openCurrent();\n      if (root == null) {\n        throw new Error(\"Missing root node name.\");\n      }\n      if (this.root) {\n        throw new Error(\"dtd() must come before the root node.\");\n      }\n      this.currentNode = new XMLDocType(this, pubID, sysID);\n      this.currentNode.rootNodeName = root;\n      this.currentNode.children = false;\n      this.currentLevel++;\n      this.openTags[this.currentLevel] = this.currentNode;\n      return this;\n    }\n\n    // Creates an element type declaration\n\n    // `name` element name\n    // `value` element content (defaults to #PCDATA)\n    dtdElement(name, value) {\n      var node;\n      this.openCurrent();\n      node = new XMLDTDElement(this, name, value);\n      this.onData(this.writer.dtdElement(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);\n      return this;\n    }\n\n    // Creates an attribute declaration\n\n    // `elementName` the name of the element containing this attribute\n    // `attributeName` attribute name\n    // `attributeType` type of the attribute (defaults to CDATA)\n    // `defaultValueType` default value type (either #REQUIRED, #IMPLIED, #FIXED or\n    //                    #DEFAULT) (defaults to #IMPLIED)\n    // `defaultValue` default value of the attribute\n    //                (only used for #FIXED or #DEFAULT)\n    attList(elementName, attributeName, attributeType, defaultValueType, defaultValue) {\n      var node;\n      this.openCurrent();\n      node = new XMLDTDAttList(this, elementName, attributeName, attributeType, defaultValueType, defaultValue);\n      this.onData(this.writer.dtdAttList(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);\n      return this;\n    }\n\n    // Creates a general entity declaration\n\n    // `name` the name of the entity\n    // `value` internal entity value or an object with external entity details\n    // `value.pubID` public identifier\n    // `value.sysID` system identifier\n    // `value.nData` notation declaration\n    entity(name, value) {\n      var node;\n      this.openCurrent();\n      node = new XMLDTDEntity(this, false, name, value);\n      this.onData(this.writer.dtdEntity(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);\n      return this;\n    }\n\n    // Creates a parameter entity declaration\n\n    // `name` the name of the entity\n    // `value` internal entity value or an object with external entity details\n    // `value.pubID` public identifier\n    // `value.sysID` system identifier\n    pEntity(name, value) {\n      var node;\n      this.openCurrent();\n      node = new XMLDTDEntity(this, true, name, value);\n      this.onData(this.writer.dtdEntity(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);\n      return this;\n    }\n\n    // Creates a NOTATION declaration\n\n    // `name` the name of the notation\n    // `value` an object with external entity details\n    // `value.pubID` public identifier\n    // `value.sysID` system identifier\n    notation(name, value) {\n      var node;\n      this.openCurrent();\n      node = new XMLDTDNotation(this, name, value);\n      this.onData(this.writer.dtdNotation(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);\n      return this;\n    }\n\n    // Gets the parent node\n    up() {\n      if (this.currentLevel < 0) {\n        throw new Error(\"The document node has no parent.\");\n      }\n      if (this.currentNode) {\n        if (this.currentNode.children) {\n          this.closeNode(this.currentNode);\n        } else {\n          this.openNode(this.currentNode);\n        }\n        this.currentNode = null;\n      } else {\n        this.closeNode(this.openTags[this.currentLevel]);\n      }\n      delete this.openTags[this.currentLevel];\n      this.currentLevel--;\n      return this;\n    }\n\n    // Ends the document\n    end() {\n      while (this.currentLevel >= 0) {\n        this.up();\n      }\n      return this.onEnd();\n    }\n\n    // Opens the current parent node\n    openCurrent() {\n      if (this.currentNode) {\n        this.currentNode.children = true;\n        return this.openNode(this.currentNode);\n      }\n    }\n\n    // Writes the opening tag of the current node or the entire node if it has\n    // no child nodes\n    openNode(node) {\n      var att, chunk, name, ref;\n      if (!node.isOpen) {\n        if (!this.root && this.currentLevel === 0 && node.type === NodeType.Element) {\n          this.root = node;\n        }\n        chunk = '';\n        if (node.type === NodeType.Element) {\n          this.writerOptions.state = WriterState.OpenTag;\n          chunk = this.writer.indent(node, this.writerOptions, this.currentLevel) + '<' + node.name;\n          ref = node.attribs;\n          for (name in ref) {\n            if (!hasProp.call(ref, name)) continue;\n            att = ref[name];\n            chunk += this.writer.attribute(att, this.writerOptions, this.currentLevel);\n          }\n          chunk += (node.children ? '>' : '/>') + this.writer.endline(node, this.writerOptions, this.currentLevel);\n          this.writerOptions.state = WriterState.InsideTag; // if node.type is NodeType.DocType\n        } else {\n          this.writerOptions.state = WriterState.OpenTag;\n          chunk = this.writer.indent(node, this.writerOptions, this.currentLevel) + '<!DOCTYPE ' + node.rootNodeName;\n          \n          // external identifier\n          if (node.pubID && node.sysID) {\n            chunk += ' PUBLIC \"' + node.pubID + '\" \"' + node.sysID + '\"';\n          } else if (node.sysID) {\n            chunk += ' SYSTEM \"' + node.sysID + '\"';\n          }\n          \n          // internal subset\n          if (node.children) {\n            chunk += ' [';\n            this.writerOptions.state = WriterState.InsideTag;\n          } else {\n            this.writerOptions.state = WriterState.CloseTag;\n            chunk += '>';\n          }\n          chunk += this.writer.endline(node, this.writerOptions, this.currentLevel);\n        }\n        this.onData(chunk, this.currentLevel);\n        return node.isOpen = true;\n      }\n    }\n\n    // Writes the closing tag of the current node\n    closeNode(node) {\n      var chunk;\n      if (!node.isClosed) {\n        chunk = '';\n        this.writerOptions.state = WriterState.CloseTag;\n        if (node.type === NodeType.Element) {\n          chunk = this.writer.indent(node, this.writerOptions, this.currentLevel) + '</' + node.name + '>' + this.writer.endline(node, this.writerOptions, this.currentLevel); // if node.type is NodeType.DocType\n        } else {\n          chunk = this.writer.indent(node, this.writerOptions, this.currentLevel) + ']>' + this.writer.endline(node, this.writerOptions, this.currentLevel);\n        }\n        this.writerOptions.state = WriterState.None;\n        this.onData(chunk, this.currentLevel);\n        return node.isClosed = true;\n      }\n    }\n\n    // Called when a new chunk of XML is output\n\n    // `chunk` a string containing the XML chunk\n    // `level` current indentation level\n    onData(chunk, level) {\n      this.documentStarted = true;\n      return this.onDataCallback(chunk, level + 1);\n    }\n\n    // Called when the XML document is completed\n    onEnd() {\n      this.documentCompleted = true;\n      return this.onEndCallback();\n    }\n\n    // Returns debug string\n    debugInfo(name) {\n      if (name == null) {\n        return \"\";\n      } else {\n        return \"node: <\" + name + \">\";\n      }\n    }\n\n    // Node aliases\n    ele() {\n      return this.element(...arguments);\n    }\n\n    nod(name, attributes, text) {\n      return this.node(name, attributes, text);\n    }\n\n    txt(value) {\n      return this.text(value);\n    }\n\n    dat(value) {\n      return this.cdata(value);\n    }\n\n    com(value) {\n      return this.comment(value);\n    }\n\n    ins(target, value) {\n      return this.instruction(target, value);\n    }\n\n    dec(version, encoding, standalone) {\n      return this.declaration(version, encoding, standalone);\n    }\n\n    dtd(root, pubID, sysID) {\n      return this.doctype(root, pubID, sysID);\n    }\n\n    e(name, attributes, text) {\n      return this.element(name, attributes, text);\n    }\n\n    n(name, attributes, text) {\n      return this.node(name, attributes, text);\n    }\n\n    t(value) {\n      return this.text(value);\n    }\n\n    d(value) {\n      return this.cdata(value);\n    }\n\n    c(value) {\n      return this.comment(value);\n    }\n\n    r(value) {\n      return this.raw(value);\n    }\n\n    i(target, value) {\n      return this.instruction(target, value);\n    }\n\n    // Attribute aliases\n    att() {\n      if (this.currentNode && this.currentNode.type === NodeType.DocType) {\n        return this.attList(...arguments);\n      } else {\n        return this.attribute(...arguments);\n      }\n    }\n\n    a() {\n      if (this.currentNode && this.currentNode.type === NodeType.DocType) {\n        return this.attList(...arguments);\n      } else {\n        return this.attribute(...arguments);\n      }\n    }\n\n    // DTD aliases\n    // att() and ele() are defined above\n    ent(name, value) {\n      return this.entity(name, value);\n    }\n\n    pent(name, value) {\n      return this.pEntity(name, value);\n    }\n\n    not(name, value) {\n      return this.notation(name, value);\n    }\n\n  };\n\n}).call(this);\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}