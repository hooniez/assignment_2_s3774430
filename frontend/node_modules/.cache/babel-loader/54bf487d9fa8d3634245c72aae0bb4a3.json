{"ast":null,"code":"// Generated by CoffeeScript 2.4.1\n(function () {\n  var DocumentPosition,\n      NodeType,\n      XMLCData,\n      XMLComment,\n      XMLDeclaration,\n      XMLDocType,\n      XMLDummy,\n      XMLElement,\n      XMLNamedNodeMap,\n      XMLNode,\n      XMLNodeList,\n      XMLProcessingInstruction,\n      XMLRaw,\n      XMLText,\n      getValue,\n      isEmpty,\n      isFunction,\n      isObject,\n      hasProp = {}.hasOwnProperty,\n      splice = [].splice;\n  ({\n    isObject,\n    isFunction,\n    isEmpty,\n    getValue\n  } = require('./Utility'));\n  XMLElement = null;\n  XMLCData = null;\n  XMLComment = null;\n  XMLDeclaration = null;\n  XMLDocType = null;\n  XMLRaw = null;\n  XMLText = null;\n  XMLProcessingInstruction = null;\n  XMLDummy = null;\n  NodeType = null;\n  XMLNodeList = null;\n  XMLNamedNodeMap = null;\n  DocumentPosition = null; // Represents a generic XMl element\n\n  module.exports = XMLNode = function () {\n    class XMLNode {\n      // Initializes a new instance of `XMLNode`\n      // `parent` the parent node\n      constructor(parent1) {\n        this.parent = parent1;\n\n        if (this.parent) {\n          this.options = this.parent.options;\n          this.stringify = this.parent.stringify;\n        }\n\n        this.value = null;\n        this.children = [];\n        this.baseURI = null; // first execution, load dependencies that are otherwise\n        // circular (so we can't load them at the top)\n\n        if (!XMLElement) {\n          XMLElement = require('./XMLElement');\n          XMLCData = require('./XMLCData');\n          XMLComment = require('./XMLComment');\n          XMLDeclaration = require('./XMLDeclaration');\n          XMLDocType = require('./XMLDocType');\n          XMLRaw = require('./XMLRaw');\n          XMLText = require('./XMLText');\n          XMLProcessingInstruction = require('./XMLProcessingInstruction');\n          XMLDummy = require('./XMLDummy');\n          NodeType = require('./NodeType');\n          XMLNodeList = require('./XMLNodeList');\n          XMLNamedNodeMap = require('./XMLNamedNodeMap');\n          DocumentPosition = require('./DocumentPosition');\n        }\n      } // Sets the parent node of this node and its children recursively\n      // `parent` the parent node\n\n\n      setParent(parent) {\n        var child, j, len, ref1, results;\n        this.parent = parent;\n\n        if (parent) {\n          this.options = parent.options;\n          this.stringify = parent.stringify;\n        }\n\n        ref1 = this.children;\n        results = [];\n\n        for (j = 0, len = ref1.length; j < len; j++) {\n          child = ref1[j];\n          results.push(child.setParent(this));\n        }\n\n        return results;\n      } // Creates a child element node\n      // `name` node name or an object describing the XML tree\n      // `attributes` an object containing name/value pairs of attributes\n      // `text` element text\n\n\n      element(name, attributes, text) {\n        var childNode, item, j, k, key, lastChild, len, len1, val;\n        lastChild = null;\n\n        if (attributes === null && text == null) {\n          [attributes, text] = [{}, null];\n        }\n\n        if (attributes == null) {\n          attributes = {};\n        }\n\n        attributes = getValue(attributes); // swap argument order: text <-> attributes\n\n        if (!isObject(attributes)) {\n          [text, attributes] = [attributes, text];\n        }\n\n        if (name != null) {\n          name = getValue(name);\n        } // expand if array\n\n\n        if (Array.isArray(name)) {\n          for (j = 0, len = name.length; j < len; j++) {\n            item = name[j];\n            lastChild = this.element(item);\n          } // evaluate if function\n\n        } else if (isFunction(name)) {\n          lastChild = this.element(name.apply()); // expand if object\n        } else if (isObject(name)) {\n          for (key in name) {\n            if (!hasProp.call(name, key)) continue;\n            val = name[key];\n\n            if (isFunction(val)) {\n              // evaluate if function\n              val = val.apply();\n            } // assign attributes\n\n\n            if (!this.options.ignoreDecorators && this.stringify.convertAttKey && key.indexOf(this.stringify.convertAttKey) === 0) {\n              lastChild = this.attribute(key.substr(this.stringify.convertAttKey.length), val); // skip empty arrays\n            } else if (!this.options.separateArrayItems && Array.isArray(val) && isEmpty(val)) {\n              lastChild = this.dummy(); // empty objects produce one node\n            } else if (isObject(val) && isEmpty(val)) {\n              lastChild = this.element(key); // skip null and undefined nodes\n            } else if (!this.options.keepNullNodes && val == null) {\n              lastChild = this.dummy(); // expand list by creating child nodes\n            } else if (!this.options.separateArrayItems && Array.isArray(val)) {\n              for (k = 0, len1 = val.length; k < len1; k++) {\n                item = val[k];\n                childNode = {};\n                childNode[key] = item;\n                lastChild = this.element(childNode);\n              } // expand child nodes under parent\n\n            } else if (isObject(val)) {\n              // if the key is #text expand child nodes under this node to support mixed content\n              if (!this.options.ignoreDecorators && this.stringify.convertTextKey && key.indexOf(this.stringify.convertTextKey) === 0) {\n                lastChild = this.element(val);\n              } else {\n                lastChild = this.element(key);\n                lastChild.element(val);\n              }\n            } else {\n              // text node\n              lastChild = this.element(key, val);\n            }\n          } // skip null nodes\n\n        } else if (!this.options.keepNullNodes && text === null) {\n          lastChild = this.dummy();\n        } else {\n          // text node\n          if (!this.options.ignoreDecorators && this.stringify.convertTextKey && name.indexOf(this.stringify.convertTextKey) === 0) {\n            lastChild = this.text(text); // cdata node\n          } else if (!this.options.ignoreDecorators && this.stringify.convertCDataKey && name.indexOf(this.stringify.convertCDataKey) === 0) {\n            lastChild = this.cdata(text); // comment node\n          } else if (!this.options.ignoreDecorators && this.stringify.convertCommentKey && name.indexOf(this.stringify.convertCommentKey) === 0) {\n            lastChild = this.comment(text); // raw text node\n          } else if (!this.options.ignoreDecorators && this.stringify.convertRawKey && name.indexOf(this.stringify.convertRawKey) === 0) {\n            lastChild = this.raw(text); // processing instruction\n          } else if (!this.options.ignoreDecorators && this.stringify.convertPIKey && name.indexOf(this.stringify.convertPIKey) === 0) {\n            lastChild = this.instruction(name.substr(this.stringify.convertPIKey.length), text);\n          } else {\n            // element node\n            lastChild = this.node(name, attributes, text);\n          }\n        }\n\n        if (lastChild == null) {\n          throw new Error(\"Could not create any elements with: \" + name + \". \" + this.debugInfo());\n        }\n\n        return lastChild;\n      } // Creates a child element node before the current node\n      // `name` node name or an object describing the XML tree\n      // `attributes` an object containing name/value pairs of attributes\n      // `text` element text\n\n\n      insertBefore(name, attributes, text) {\n        var child, i, newChild, refChild, removed; // DOM level 1\n        // insertBefore(newChild, refChild) inserts the child node newChild before refChild\n\n        if (name != null ? name.type : void 0) {\n          newChild = name;\n          refChild = attributes;\n          newChild.setParent(this);\n\n          if (refChild) {\n            // temporarily remove children starting *with* refChild\n            i = children.indexOf(refChild);\n            removed = children.splice(i); // add the new child\n\n            children.push(newChild); // add back removed children after new child\n\n            Array.prototype.push.apply(children, removed);\n          } else {\n            children.push(newChild);\n          }\n\n          return newChild;\n        } else {\n          if (this.isRoot) {\n            throw new Error(\"Cannot insert elements at root level. \" + this.debugInfo(name));\n          } // temporarily remove children starting *with* this\n\n\n          i = this.parent.children.indexOf(this);\n          removed = this.parent.children.splice(i); // add the new child\n\n          child = this.parent.element(name, attributes, text); // add back removed children after new child\n\n          Array.prototype.push.apply(this.parent.children, removed);\n          return child;\n        }\n      } // Creates a child element node after the current node\n      // `name` node name or an object describing the XML tree\n      // `attributes` an object containing name/value pairs of attributes\n      // `text` element text\n\n\n      insertAfter(name, attributes, text) {\n        var child, i, removed;\n\n        if (this.isRoot) {\n          throw new Error(\"Cannot insert elements at root level. \" + this.debugInfo(name));\n        } // temporarily remove children starting *after* this\n\n\n        i = this.parent.children.indexOf(this);\n        removed = this.parent.children.splice(i + 1); // add the new child\n\n        child = this.parent.element(name, attributes, text); // add back removed children after new child\n\n        Array.prototype.push.apply(this.parent.children, removed);\n        return child;\n      } // Deletes a child element node\n\n\n      remove() {\n        var i, ref1;\n\n        if (this.isRoot) {\n          throw new Error(\"Cannot remove the root element. \" + this.debugInfo());\n        }\n\n        i = this.parent.children.indexOf(this);\n        splice.apply(this.parent.children, [i, i - i + 1].concat(ref1 = [])), ref1;\n        return this.parent;\n      } // Creates a node\n      // `name` name of the node\n      // `attributes` an object containing name/value pairs of attributes\n      // `text` element text\n\n\n      node(name, attributes, text) {\n        var child;\n\n        if (name != null) {\n          name = getValue(name);\n        }\n\n        attributes || (attributes = {});\n        attributes = getValue(attributes); // swap argument order: text <-> attributes\n\n        if (!isObject(attributes)) {\n          [text, attributes] = [attributes, text];\n        }\n\n        child = new XMLElement(this, name, attributes);\n\n        if (text != null) {\n          child.text(text);\n        }\n\n        this.children.push(child);\n        return child;\n      } // Creates a text node\n      // `value` element text\n\n\n      text(value) {\n        var child;\n\n        if (isObject(value)) {\n          this.element(value);\n        }\n\n        child = new XMLText(this, value);\n        this.children.push(child);\n        return this;\n      } // Creates a CDATA node\n      // `value` element text without CDATA delimiters\n\n\n      cdata(value) {\n        var child;\n        child = new XMLCData(this, value);\n        this.children.push(child);\n        return this;\n      } // Creates a comment node\n      // `value` comment text\n\n\n      comment(value) {\n        var child;\n        child = new XMLComment(this, value);\n        this.children.push(child);\n        return this;\n      } // Creates a comment node before the current node\n      // `value` comment text\n\n\n      commentBefore(value) {\n        var child, i, removed; // temporarily remove children starting *with* this\n\n        i = this.parent.children.indexOf(this);\n        removed = this.parent.children.splice(i); // add the new child\n\n        child = this.parent.comment(value); // add back removed children after new child\n\n        Array.prototype.push.apply(this.parent.children, removed);\n        return this;\n      } // Creates a comment node after the current node\n      // `value` comment text\n\n\n      commentAfter(value) {\n        var child, i, removed; // temporarily remove children starting *after* this\n\n        i = this.parent.children.indexOf(this);\n        removed = this.parent.children.splice(i + 1); // add the new child\n\n        child = this.parent.comment(value); // add back removed children after new child\n\n        Array.prototype.push.apply(this.parent.children, removed);\n        return this;\n      } // Adds unescaped raw text\n      // `value` text\n\n\n      raw(value) {\n        var child;\n        child = new XMLRaw(this, value);\n        this.children.push(child);\n        return this;\n      } // Adds a dummy node\n\n\n      dummy() {\n        var child;\n        child = new XMLDummy(this); // Normally when a new node is created it is added to the child node collection.\n        // However, dummy nodes are never added to the XML tree. They are created while\n        // converting JS objects to XML nodes in order not to break the recursive function\n        // chain. They can be thought of as invisible nodes. They can be traversed through\n        // by using prev(), next(), up(), etc. functions but they do not exists in the tree.\n        // @children.push child\n\n        return child;\n      } // Adds a processing instruction\n      // `target` instruction target\n      // `value` instruction value\n\n\n      instruction(target, value) {\n        var insTarget, insValue, instruction, j, len;\n\n        if (target != null) {\n          target = getValue(target);\n        }\n\n        if (value != null) {\n          value = getValue(value);\n        }\n\n        if (Array.isArray(target)) {\n          // expand if array\n          for (j = 0, len = target.length; j < len; j++) {\n            insTarget = target[j];\n            this.instruction(insTarget);\n          }\n        } else if (isObject(target)) {\n          // expand if object\n          for (insTarget in target) {\n            if (!hasProp.call(target, insTarget)) continue;\n            insValue = target[insTarget];\n            this.instruction(insTarget, insValue);\n          }\n        } else {\n          if (isFunction(value)) {\n            value = value.apply();\n          }\n\n          instruction = new XMLProcessingInstruction(this, target, value);\n          this.children.push(instruction);\n        }\n\n        return this;\n      } // Creates a processing instruction node before the current node\n      // `target` instruction target\n      // `value` instruction value\n\n\n      instructionBefore(target, value) {\n        var child, i, removed; // temporarily remove children starting *with* this\n\n        i = this.parent.children.indexOf(this);\n        removed = this.parent.children.splice(i); // add the new child\n\n        child = this.parent.instruction(target, value); // add back removed children after new child\n\n        Array.prototype.push.apply(this.parent.children, removed);\n        return this;\n      } // Creates a processing instruction node after the current node\n      // `target` instruction target\n      // `value` instruction value\n\n\n      instructionAfter(target, value) {\n        var child, i, removed; // temporarily remove children starting *after* this\n\n        i = this.parent.children.indexOf(this);\n        removed = this.parent.children.splice(i + 1); // add the new child\n\n        child = this.parent.instruction(target, value); // add back removed children after new child\n\n        Array.prototype.push.apply(this.parent.children, removed);\n        return this;\n      } // Creates the xml declaration\n      // `version` A version number string, e.g. 1.0\n      // `encoding` Encoding declaration, e.g. UTF-8\n      // `standalone` standalone document declaration: true or false\n\n\n      declaration(version, encoding, standalone) {\n        var doc, xmldec;\n        doc = this.document();\n        xmldec = new XMLDeclaration(doc, version, encoding, standalone); // Replace XML declaration if exists, otherwise insert at top\n\n        if (doc.children.length === 0) {\n          doc.children.unshift(xmldec);\n        } else if (doc.children[0].type === NodeType.Declaration) {\n          doc.children[0] = xmldec;\n        } else {\n          doc.children.unshift(xmldec);\n        }\n\n        return doc.root() || doc;\n      } // Creates the document type declaration\n      // `pubID` the public identifier of the external subset\n      // `sysID` the system identifier of the external subset\n\n\n      dtd(pubID, sysID) {\n        var child, doc, doctype, i, j, k, len, len1, ref1, ref2;\n        doc = this.document();\n        doctype = new XMLDocType(doc, pubID, sysID);\n        ref1 = doc.children; // Replace DTD if exists\n\n        for (i = j = 0, len = ref1.length; j < len; i = ++j) {\n          child = ref1[i];\n\n          if (child.type === NodeType.DocType) {\n            doc.children[i] = doctype;\n            return doctype;\n          }\n        }\n\n        ref2 = doc.children; // insert before root node if the root node exists\n\n        for (i = k = 0, len1 = ref2.length; k < len1; i = ++k) {\n          child = ref2[i];\n\n          if (child.isRoot) {\n            doc.children.splice(i, 0, doctype);\n            return doctype;\n          }\n        } // otherwise append to end\n\n\n        doc.children.push(doctype);\n        return doctype;\n      } // Gets the parent node\n\n\n      up() {\n        if (this.isRoot) {\n          throw new Error(\"The root node has no parent. Use doc() if you need to get the document object.\");\n        }\n\n        return this.parent;\n      } // Gets the root node\n\n\n      root() {\n        var node;\n        node = this;\n\n        while (node) {\n          if (node.type === NodeType.Document) {\n            return node.rootObject;\n          } else if (node.isRoot) {\n            return node;\n          } else {\n            node = node.parent;\n          }\n        }\n      } // Gets the node representing the XML document\n\n\n      document() {\n        var node;\n        node = this;\n\n        while (node) {\n          if (node.type === NodeType.Document) {\n            return node;\n          } else {\n            node = node.parent;\n          }\n        }\n      } // Ends the document and converts string\n\n\n      end(options) {\n        return this.document().end(options);\n      } // Gets the previous node\n\n\n      prev() {\n        var i;\n        i = this.parent.children.indexOf(this);\n\n        if (i < 1) {\n          throw new Error(\"Already at the first node. \" + this.debugInfo());\n        }\n\n        return this.parent.children[i - 1];\n      } // Gets the next node\n\n\n      next() {\n        var i;\n        i = this.parent.children.indexOf(this);\n\n        if (i === -1 || i === this.parent.children.length - 1) {\n          throw new Error(\"Already at the last node. \" + this.debugInfo());\n        }\n\n        return this.parent.children[i + 1];\n      } // Imports cloned root from another XML document\n      // `doc` the XML document to insert nodes from\n\n\n      importDocument(doc) {\n        var child, clonedRoot, j, len, ref1;\n        clonedRoot = doc.root().clone();\n        clonedRoot.parent = this;\n        clonedRoot.isRoot = false;\n        this.children.push(clonedRoot); // set properties if imported element becomes the root node\n\n        if (this.type === NodeType.Document) {\n          clonedRoot.isRoot = true;\n          clonedRoot.documentObject = this;\n          this.rootObject = clonedRoot; // set dtd name\n\n          if (this.children) {\n            ref1 = this.children;\n\n            for (j = 0, len = ref1.length; j < len; j++) {\n              child = ref1[j];\n\n              if (child.type === NodeType.DocType) {\n                child.name = clonedRoot.name;\n                break;\n              }\n            }\n          }\n        }\n\n        return this;\n      } // Returns debug string for this node\n\n\n      debugInfo(name) {\n        var ref1, ref2;\n        name = name || this.name;\n\n        if (name == null && !((ref1 = this.parent) != null ? ref1.name : void 0)) {\n          return \"\";\n        } else if (name == null) {\n          return \"parent: <\" + this.parent.name + \">\";\n        } else if (!((ref2 = this.parent) != null ? ref2.name : void 0)) {\n          return \"node: <\" + name + \">\";\n        } else {\n          return \"node: <\" + name + \">, parent: <\" + this.parent.name + \">\";\n        }\n      } // Aliases\n\n\n      ele(name, attributes, text) {\n        return this.element(name, attributes, text);\n      }\n\n      nod(name, attributes, text) {\n        return this.node(name, attributes, text);\n      }\n\n      txt(value) {\n        return this.text(value);\n      }\n\n      dat(value) {\n        return this.cdata(value);\n      }\n\n      com(value) {\n        return this.comment(value);\n      }\n\n      ins(target, value) {\n        return this.instruction(target, value);\n      }\n\n      doc() {\n        return this.document();\n      }\n\n      dec(version, encoding, standalone) {\n        return this.declaration(version, encoding, standalone);\n      }\n\n      e(name, attributes, text) {\n        return this.element(name, attributes, text);\n      }\n\n      n(name, attributes, text) {\n        return this.node(name, attributes, text);\n      }\n\n      t(value) {\n        return this.text(value);\n      }\n\n      d(value) {\n        return this.cdata(value);\n      }\n\n      c(value) {\n        return this.comment(value);\n      }\n\n      r(value) {\n        return this.raw(value);\n      }\n\n      i(target, value) {\n        return this.instruction(target, value);\n      }\n\n      u() {\n        return this.up();\n      } // can be deprecated in a future release\n\n\n      importXMLBuilder(doc) {\n        return this.importDocument(doc);\n      } // Adds or modifies an attribute.\n      // `name` attribute name\n      // `value` attribute value\n\n\n      attribute(name, value) {\n        throw new Error(\"attribute() applies to element nodes only.\");\n      }\n\n      att(name, value) {\n        return this.attribute(name, value);\n      }\n\n      a(name, value) {\n        return this.attribute(name, value);\n      } // Removes an attribute\n      // `name` attribute name\n\n\n      removeAttribute(name) {\n        throw new Error(\"attribute() applies to element nodes only.\");\n      } // DOM level 1 functions to be implemented later\n\n\n      replaceChild(newChild, oldChild) {\n        throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n      }\n\n      removeChild(oldChild) {\n        throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n      }\n\n      appendChild(newChild) {\n        throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n      }\n\n      hasChildNodes() {\n        return this.children.length !== 0;\n      }\n\n      cloneNode(deep) {\n        throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n      }\n\n      normalize() {\n        throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n      } // DOM level 2\n\n\n      isSupported(feature, version) {\n        return true;\n      }\n\n      hasAttributes() {\n        return this.attribs.length !== 0;\n      } // DOM level 3 functions to be implemented later\n\n\n      compareDocumentPosition(other) {\n        var ref, res;\n        ref = this;\n\n        if (ref === other) {\n          return 0;\n        } else if (this.document() !== other.document()) {\n          res = DocumentPosition.Disconnected | DocumentPosition.ImplementationSpecific;\n\n          if (Math.random() < 0.5) {\n            res |= DocumentPosition.Preceding;\n          } else {\n            res |= DocumentPosition.Following;\n          }\n\n          return res;\n        } else if (ref.isAncestor(other)) {\n          return DocumentPosition.Contains | DocumentPosition.Preceding;\n        } else if (ref.isDescendant(other)) {\n          return DocumentPosition.Contains | DocumentPosition.Following;\n        } else if (ref.isPreceding(other)) {\n          return DocumentPosition.Preceding;\n        } else {\n          return DocumentPosition.Following;\n        }\n      }\n\n      isSameNode(other) {\n        throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n      }\n\n      lookupPrefix(namespaceURI) {\n        throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n      }\n\n      isDefaultNamespace(namespaceURI) {\n        throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n      }\n\n      lookupNamespaceURI(prefix) {\n        throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n      }\n\n      isEqualNode(node) {\n        var i, j, ref1;\n\n        if (node.nodeType !== this.nodeType) {\n          return false;\n        }\n\n        if (node.children.length !== this.children.length) {\n          return false;\n        }\n\n        for (i = j = 0, ref1 = this.children.length - 1; 0 <= ref1 ? j <= ref1 : j >= ref1; i = 0 <= ref1 ? ++j : --j) {\n          if (!this.children[i].isEqualNode(node.children[i])) {\n            return false;\n          }\n        }\n\n        return true;\n      }\n\n      getFeature(feature, version) {\n        throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n      }\n\n      setUserData(key, data, handler) {\n        throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n      }\n\n      getUserData(key) {\n        throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n      } // Returns true if other is an inclusive descendant of node,\n      // and false otherwise.\n\n\n      contains(other) {\n        if (!other) {\n          return false;\n        }\n\n        return other === this || this.isDescendant(other);\n      } // An object A is called a descendant of an object B, if either A is \n      // a child of B or A is a child of an object C that is a descendant of B.\n\n\n      isDescendant(node) {\n        var child, isDescendantChild, j, len, ref1;\n        ref1 = this.children;\n\n        for (j = 0, len = ref1.length; j < len; j++) {\n          child = ref1[j];\n\n          if (node === child) {\n            return true;\n          }\n\n          isDescendantChild = child.isDescendant(node);\n\n          if (isDescendantChild) {\n            return true;\n          }\n        }\n\n        return false;\n      } // An object A is called an ancestor of an object B if and only if\n      // B is a descendant of A.\n\n\n      isAncestor(node) {\n        return node.isDescendant(this);\n      } // An object A is preceding an object B if A and B are in the \n      // same tree and A comes before B in tree order.\n\n\n      isPreceding(node) {\n        var nodePos, thisPos;\n        nodePos = this.treePosition(node);\n        thisPos = this.treePosition(this);\n\n        if (nodePos === -1 || thisPos === -1) {\n          return false;\n        } else {\n          return nodePos < thisPos;\n        }\n      } // An object A is folllowing an object B if A and B are in the \n      // same tree and A comes after B in tree order.\n\n\n      isFollowing(node) {\n        var nodePos, thisPos;\n        nodePos = this.treePosition(node);\n        thisPos = this.treePosition(this);\n\n        if (nodePos === -1 || thisPos === -1) {\n          return false;\n        } else {\n          return nodePos > thisPos;\n        }\n      } // Returns the preorder position of the given node in the tree, or -1\n      // if the node is not in the tree.\n\n\n      treePosition(node) {\n        var found, pos;\n        pos = 0;\n        found = false;\n        this.foreachTreeNode(this.document(), function (childNode) {\n          pos++;\n\n          if (!found && childNode === node) {\n            return found = true;\n          }\n        });\n\n        if (found) {\n          return pos;\n        } else {\n          return -1;\n        }\n      } // Depth-first preorder traversal through the XML tree\n\n\n      foreachTreeNode(node, func) {\n        var child, j, len, ref1, res;\n        node || (node = this.document());\n        ref1 = node.children;\n\n        for (j = 0, len = ref1.length; j < len; j++) {\n          child = ref1[j];\n\n          if (res = func(child)) {\n            return res;\n          } else {\n            res = this.foreachTreeNode(child, func);\n\n            if (res) {\n              return res;\n            }\n          }\n        }\n      }\n\n    }\n\n    ; // DOM level 1\n\n    Object.defineProperty(XMLNode.prototype, 'nodeName', {\n      get: function () {\n        return this.name;\n      }\n    });\n    Object.defineProperty(XMLNode.prototype, 'nodeType', {\n      get: function () {\n        return this.type;\n      }\n    });\n    Object.defineProperty(XMLNode.prototype, 'nodeValue', {\n      get: function () {\n        return this.value;\n      }\n    });\n    Object.defineProperty(XMLNode.prototype, 'parentNode', {\n      get: function () {\n        return this.parent;\n      }\n    });\n    Object.defineProperty(XMLNode.prototype, 'childNodes', {\n      get: function () {\n        if (!this.childNodeList || !this.childNodeList.nodes) {\n          this.childNodeList = new XMLNodeList(this.children);\n        }\n\n        return this.childNodeList;\n      }\n    });\n    Object.defineProperty(XMLNode.prototype, 'firstChild', {\n      get: function () {\n        return this.children[0] || null;\n      }\n    });\n    Object.defineProperty(XMLNode.prototype, 'lastChild', {\n      get: function () {\n        return this.children[this.children.length - 1] || null;\n      }\n    });\n    Object.defineProperty(XMLNode.prototype, 'previousSibling', {\n      get: function () {\n        var i;\n        i = this.parent.children.indexOf(this);\n        return this.parent.children[i - 1] || null;\n      }\n    });\n    Object.defineProperty(XMLNode.prototype, 'nextSibling', {\n      get: function () {\n        var i;\n        i = this.parent.children.indexOf(this);\n        return this.parent.children[i + 1] || null;\n      }\n    });\n    Object.defineProperty(XMLNode.prototype, 'ownerDocument', {\n      get: function () {\n        return this.document() || null;\n      }\n    }); // DOM level 3\n\n    Object.defineProperty(XMLNode.prototype, 'textContent', {\n      get: function () {\n        var child, j, len, ref1, str;\n\n        if (this.nodeType === NodeType.Element || this.nodeType === NodeType.DocumentFragment) {\n          str = '';\n          ref1 = this.children;\n\n          for (j = 0, len = ref1.length; j < len; j++) {\n            child = ref1[j];\n\n            if (child.textContent) {\n              str += child.textContent;\n            }\n          }\n\n          return str;\n        } else {\n          return null;\n        }\n      },\n      set: function (value) {\n        throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n      }\n    });\n    return XMLNode;\n  }.call(this);\n}).call(this);","map":{"version":3,"names":["DocumentPosition","NodeType","XMLCData","XMLComment","XMLDeclaration","XMLDocType","XMLDummy","XMLElement","XMLNamedNodeMap","XMLNode","XMLNodeList","XMLProcessingInstruction","XMLRaw","XMLText","getValue","isEmpty","isFunction","isObject","hasProp","hasOwnProperty","splice","require","module","exports","constructor","parent1","parent","options","stringify","value","children","baseURI","setParent","child","j","len","ref1","results","length","push","element","name","attributes","text","childNode","item","k","key","lastChild","len1","val","Array","isArray","apply","call","ignoreDecorators","convertAttKey","indexOf","attribute","substr","separateArrayItems","dummy","keepNullNodes","convertTextKey","convertCDataKey","cdata","convertCommentKey","comment","convertRawKey","raw","convertPIKey","instruction","node","Error","debugInfo","insertBefore","i","newChild","refChild","removed","type","prototype","isRoot","insertAfter","remove","concat","commentBefore","commentAfter","target","insTarget","insValue","instructionBefore","instructionAfter","declaration","version","encoding","standalone","doc","xmldec","document","unshift","Declaration","root","dtd","pubID","sysID","doctype","ref2","DocType","up","Document","rootObject","end","prev","next","importDocument","clonedRoot","clone","documentObject","ele","nod","txt","dat","com","ins","dec","e","n","t","d","c","r","u","importXMLBuilder","att","a","removeAttribute","replaceChild","oldChild","removeChild","appendChild","hasChildNodes","cloneNode","deep","normalize","isSupported","feature","hasAttributes","attribs","compareDocumentPosition","other","ref","res","Disconnected","ImplementationSpecific","Math","random","Preceding","Following","isAncestor","Contains","isDescendant","isPreceding","isSameNode","lookupPrefix","namespaceURI","isDefaultNamespace","lookupNamespaceURI","prefix","isEqualNode","nodeType","getFeature","setUserData","data","handler","getUserData","contains","isDescendantChild","nodePos","thisPos","treePosition","isFollowing","found","pos","foreachTreeNode","func","Object","defineProperty","get","childNodeList","nodes","str","Element","DocumentFragment","textContent","set"],"sources":["/Users/hooniesun/rmit/fwp/assessment1/lan/node_modules/xmlbuilder/lib/XMLNode.js"],"sourcesContent":["// Generated by CoffeeScript 2.4.1\n(function() {\n  var DocumentPosition, NodeType, XMLCData, XMLComment, XMLDeclaration, XMLDocType, XMLDummy, XMLElement, XMLNamedNodeMap, XMLNode, XMLNodeList, XMLProcessingInstruction, XMLRaw, XMLText, getValue, isEmpty, isFunction, isObject,\n    hasProp = {}.hasOwnProperty,\n    splice = [].splice;\n\n  ({isObject, isFunction, isEmpty, getValue} = require('./Utility'));\n\n  XMLElement = null;\n\n  XMLCData = null;\n\n  XMLComment = null;\n\n  XMLDeclaration = null;\n\n  XMLDocType = null;\n\n  XMLRaw = null;\n\n  XMLText = null;\n\n  XMLProcessingInstruction = null;\n\n  XMLDummy = null;\n\n  NodeType = null;\n\n  XMLNodeList = null;\n\n  XMLNamedNodeMap = null;\n\n  DocumentPosition = null;\n\n  // Represents a generic XMl element\n  module.exports = XMLNode = (function() {\n    class XMLNode {\n      // Initializes a new instance of `XMLNode`\n\n      // `parent` the parent node\n      constructor(parent1) {\n        this.parent = parent1;\n        if (this.parent) {\n          this.options = this.parent.options;\n          this.stringify = this.parent.stringify;\n        }\n        this.value = null;\n        this.children = [];\n        this.baseURI = null;\n        // first execution, load dependencies that are otherwise\n        // circular (so we can't load them at the top)\n        if (!XMLElement) {\n          XMLElement = require('./XMLElement');\n          XMLCData = require('./XMLCData');\n          XMLComment = require('./XMLComment');\n          XMLDeclaration = require('./XMLDeclaration');\n          XMLDocType = require('./XMLDocType');\n          XMLRaw = require('./XMLRaw');\n          XMLText = require('./XMLText');\n          XMLProcessingInstruction = require('./XMLProcessingInstruction');\n          XMLDummy = require('./XMLDummy');\n          NodeType = require('./NodeType');\n          XMLNodeList = require('./XMLNodeList');\n          XMLNamedNodeMap = require('./XMLNamedNodeMap');\n          DocumentPosition = require('./DocumentPosition');\n        }\n      }\n\n      \n      // Sets the parent node of this node and its children recursively\n\n      // `parent` the parent node\n      setParent(parent) {\n        var child, j, len, ref1, results;\n        this.parent = parent;\n        if (parent) {\n          this.options = parent.options;\n          this.stringify = parent.stringify;\n        }\n        ref1 = this.children;\n        results = [];\n        for (j = 0, len = ref1.length; j < len; j++) {\n          child = ref1[j];\n          results.push(child.setParent(this));\n        }\n        return results;\n      }\n\n      // Creates a child element node\n\n      // `name` node name or an object describing the XML tree\n      // `attributes` an object containing name/value pairs of attributes\n      // `text` element text\n      element(name, attributes, text) {\n        var childNode, item, j, k, key, lastChild, len, len1, val;\n        lastChild = null;\n        if (attributes === null && (text == null)) {\n          [attributes, text] = [{}, null];\n        }\n        if (attributes == null) {\n          attributes = {};\n        }\n        attributes = getValue(attributes);\n        // swap argument order: text <-> attributes\n        if (!isObject(attributes)) {\n          [text, attributes] = [attributes, text];\n        }\n        if (name != null) {\n          name = getValue(name);\n        }\n        // expand if array\n        if (Array.isArray(name)) {\n          for (j = 0, len = name.length; j < len; j++) {\n            item = name[j];\n            lastChild = this.element(item);\n          }\n        // evaluate if function\n        } else if (isFunction(name)) {\n          lastChild = this.element(name.apply());\n        // expand if object\n        } else if (isObject(name)) {\n          for (key in name) {\n            if (!hasProp.call(name, key)) continue;\n            val = name[key];\n            if (isFunction(val)) {\n              // evaluate if function\n              val = val.apply();\n            }\n            // assign attributes\n            if (!this.options.ignoreDecorators && this.stringify.convertAttKey && key.indexOf(this.stringify.convertAttKey) === 0) {\n              lastChild = this.attribute(key.substr(this.stringify.convertAttKey.length), val);\n            // skip empty arrays\n            } else if (!this.options.separateArrayItems && Array.isArray(val) && isEmpty(val)) {\n              lastChild = this.dummy();\n            // empty objects produce one node\n            } else if (isObject(val) && isEmpty(val)) {\n              lastChild = this.element(key);\n            // skip null and undefined nodes\n            } else if (!this.options.keepNullNodes && (val == null)) {\n              lastChild = this.dummy();\n            \n            // expand list by creating child nodes\n            } else if (!this.options.separateArrayItems && Array.isArray(val)) {\n              for (k = 0, len1 = val.length; k < len1; k++) {\n                item = val[k];\n                childNode = {};\n                childNode[key] = item;\n                lastChild = this.element(childNode);\n              }\n            \n            // expand child nodes under parent\n            } else if (isObject(val)) {\n              // if the key is #text expand child nodes under this node to support mixed content\n              if (!this.options.ignoreDecorators && this.stringify.convertTextKey && key.indexOf(this.stringify.convertTextKey) === 0) {\n                lastChild = this.element(val);\n              } else {\n                lastChild = this.element(key);\n                lastChild.element(val);\n              }\n            } else {\n              \n              // text node\n              lastChild = this.element(key, val);\n            }\n          }\n        // skip null nodes\n        } else if (!this.options.keepNullNodes && text === null) {\n          lastChild = this.dummy();\n        } else {\n          // text node\n          if (!this.options.ignoreDecorators && this.stringify.convertTextKey && name.indexOf(this.stringify.convertTextKey) === 0) {\n            lastChild = this.text(text);\n          // cdata node\n          } else if (!this.options.ignoreDecorators && this.stringify.convertCDataKey && name.indexOf(this.stringify.convertCDataKey) === 0) {\n            lastChild = this.cdata(text);\n          // comment node\n          } else if (!this.options.ignoreDecorators && this.stringify.convertCommentKey && name.indexOf(this.stringify.convertCommentKey) === 0) {\n            lastChild = this.comment(text);\n          // raw text node\n          } else if (!this.options.ignoreDecorators && this.stringify.convertRawKey && name.indexOf(this.stringify.convertRawKey) === 0) {\n            lastChild = this.raw(text);\n          // processing instruction\n          } else if (!this.options.ignoreDecorators && this.stringify.convertPIKey && name.indexOf(this.stringify.convertPIKey) === 0) {\n            lastChild = this.instruction(name.substr(this.stringify.convertPIKey.length), text);\n          } else {\n            // element node\n            lastChild = this.node(name, attributes, text);\n          }\n        }\n        if (lastChild == null) {\n          throw new Error(\"Could not create any elements with: \" + name + \". \" + this.debugInfo());\n        }\n        return lastChild;\n      }\n\n      // Creates a child element node before the current node\n\n      // `name` node name or an object describing the XML tree\n      // `attributes` an object containing name/value pairs of attributes\n      // `text` element text\n      insertBefore(name, attributes, text) {\n        var child, i, newChild, refChild, removed;\n        // DOM level 1\n        // insertBefore(newChild, refChild) inserts the child node newChild before refChild\n        if (name != null ? name.type : void 0) {\n          newChild = name;\n          refChild = attributes;\n          newChild.setParent(this);\n          if (refChild) {\n            // temporarily remove children starting *with* refChild\n            i = children.indexOf(refChild);\n            removed = children.splice(i);\n            \n            // add the new child\n            children.push(newChild);\n            \n            // add back removed children after new child\n            Array.prototype.push.apply(children, removed);\n          } else {\n            children.push(newChild);\n          }\n          return newChild;\n        } else {\n          if (this.isRoot) {\n            throw new Error(\"Cannot insert elements at root level. \" + this.debugInfo(name));\n          }\n          \n          // temporarily remove children starting *with* this\n          i = this.parent.children.indexOf(this);\n          removed = this.parent.children.splice(i);\n          \n          // add the new child\n          child = this.parent.element(name, attributes, text);\n          \n          // add back removed children after new child\n          Array.prototype.push.apply(this.parent.children, removed);\n          return child;\n        }\n      }\n\n      // Creates a child element node after the current node\n\n      // `name` node name or an object describing the XML tree\n      // `attributes` an object containing name/value pairs of attributes\n      // `text` element text\n      insertAfter(name, attributes, text) {\n        var child, i, removed;\n        if (this.isRoot) {\n          throw new Error(\"Cannot insert elements at root level. \" + this.debugInfo(name));\n        }\n        \n        // temporarily remove children starting *after* this\n        i = this.parent.children.indexOf(this);\n        removed = this.parent.children.splice(i + 1);\n        \n        // add the new child\n        child = this.parent.element(name, attributes, text);\n        \n        // add back removed children after new child\n        Array.prototype.push.apply(this.parent.children, removed);\n        return child;\n      }\n\n      // Deletes a child element node\n\n      remove() {\n        var i, ref1;\n        if (this.isRoot) {\n          throw new Error(\"Cannot remove the root element. \" + this.debugInfo());\n        }\n        i = this.parent.children.indexOf(this);\n        splice.apply(this.parent.children, [i, i - i + 1].concat(ref1 = [])), ref1;\n        return this.parent;\n      }\n\n      // Creates a node\n\n      // `name` name of the node\n      // `attributes` an object containing name/value pairs of attributes\n      // `text` element text\n      node(name, attributes, text) {\n        var child;\n        if (name != null) {\n          name = getValue(name);\n        }\n        attributes || (attributes = {});\n        attributes = getValue(attributes);\n        // swap argument order: text <-> attributes\n        if (!isObject(attributes)) {\n          [text, attributes] = [attributes, text];\n        }\n        child = new XMLElement(this, name, attributes);\n        if (text != null) {\n          child.text(text);\n        }\n        this.children.push(child);\n        return child;\n      }\n\n      // Creates a text node\n\n      // `value` element text\n      text(value) {\n        var child;\n        if (isObject(value)) {\n          this.element(value);\n        }\n        child = new XMLText(this, value);\n        this.children.push(child);\n        return this;\n      }\n\n      // Creates a CDATA node\n\n      // `value` element text without CDATA delimiters\n      cdata(value) {\n        var child;\n        child = new XMLCData(this, value);\n        this.children.push(child);\n        return this;\n      }\n\n      // Creates a comment node\n\n      // `value` comment text\n      comment(value) {\n        var child;\n        child = new XMLComment(this, value);\n        this.children.push(child);\n        return this;\n      }\n\n      // Creates a comment node before the current node\n\n      // `value` comment text\n      commentBefore(value) {\n        var child, i, removed;\n        // temporarily remove children starting *with* this\n        i = this.parent.children.indexOf(this);\n        removed = this.parent.children.splice(i);\n        // add the new child\n        child = this.parent.comment(value);\n        // add back removed children after new child\n        Array.prototype.push.apply(this.parent.children, removed);\n        return this;\n      }\n\n      // Creates a comment node after the current node\n\n      // `value` comment text\n      commentAfter(value) {\n        var child, i, removed;\n        // temporarily remove children starting *after* this\n        i = this.parent.children.indexOf(this);\n        removed = this.parent.children.splice(i + 1);\n        // add the new child\n        child = this.parent.comment(value);\n        // add back removed children after new child\n        Array.prototype.push.apply(this.parent.children, removed);\n        return this;\n      }\n\n      // Adds unescaped raw text\n\n      // `value` text\n      raw(value) {\n        var child;\n        child = new XMLRaw(this, value);\n        this.children.push(child);\n        return this;\n      }\n\n      // Adds a dummy node\n      dummy() {\n        var child;\n        child = new XMLDummy(this);\n        // Normally when a new node is created it is added to the child node collection.\n        // However, dummy nodes are never added to the XML tree. They are created while\n        // converting JS objects to XML nodes in order not to break the recursive function\n        // chain. They can be thought of as invisible nodes. They can be traversed through\n        // by using prev(), next(), up(), etc. functions but they do not exists in the tree.\n\n        // @children.push child\n        return child;\n      }\n\n      // Adds a processing instruction\n\n      // `target` instruction target\n      // `value` instruction value\n      instruction(target, value) {\n        var insTarget, insValue, instruction, j, len;\n        if (target != null) {\n          target = getValue(target);\n        }\n        if (value != null) {\n          value = getValue(value);\n        }\n        if (Array.isArray(target)) { // expand if array\n          for (j = 0, len = target.length; j < len; j++) {\n            insTarget = target[j];\n            this.instruction(insTarget);\n          }\n        } else if (isObject(target)) { // expand if object\n          for (insTarget in target) {\n            if (!hasProp.call(target, insTarget)) continue;\n            insValue = target[insTarget];\n            this.instruction(insTarget, insValue);\n          }\n        } else {\n          if (isFunction(value)) {\n            value = value.apply();\n          }\n          instruction = new XMLProcessingInstruction(this, target, value);\n          this.children.push(instruction);\n        }\n        return this;\n      }\n\n      // Creates a processing instruction node before the current node\n\n      // `target` instruction target\n      // `value` instruction value\n      instructionBefore(target, value) {\n        var child, i, removed;\n        // temporarily remove children starting *with* this\n        i = this.parent.children.indexOf(this);\n        removed = this.parent.children.splice(i);\n        // add the new child\n        child = this.parent.instruction(target, value);\n        // add back removed children after new child\n        Array.prototype.push.apply(this.parent.children, removed);\n        return this;\n      }\n\n      // Creates a processing instruction node after the current node\n\n      // `target` instruction target\n      // `value` instruction value\n      instructionAfter(target, value) {\n        var child, i, removed;\n        // temporarily remove children starting *after* this\n        i = this.parent.children.indexOf(this);\n        removed = this.parent.children.splice(i + 1);\n        // add the new child\n        child = this.parent.instruction(target, value);\n        // add back removed children after new child\n        Array.prototype.push.apply(this.parent.children, removed);\n        return this;\n      }\n\n      // Creates the xml declaration\n\n      // `version` A version number string, e.g. 1.0\n      // `encoding` Encoding declaration, e.g. UTF-8\n      // `standalone` standalone document declaration: true or false\n      declaration(version, encoding, standalone) {\n        var doc, xmldec;\n        doc = this.document();\n        xmldec = new XMLDeclaration(doc, version, encoding, standalone);\n        // Replace XML declaration if exists, otherwise insert at top\n        if (doc.children.length === 0) {\n          doc.children.unshift(xmldec);\n        } else if (doc.children[0].type === NodeType.Declaration) {\n          doc.children[0] = xmldec;\n        } else {\n          doc.children.unshift(xmldec);\n        }\n        return doc.root() || doc;\n      }\n\n      // Creates the document type declaration\n\n      // `pubID` the public identifier of the external subset\n      // `sysID` the system identifier of the external subset\n      dtd(pubID, sysID) {\n        var child, doc, doctype, i, j, k, len, len1, ref1, ref2;\n        doc = this.document();\n        doctype = new XMLDocType(doc, pubID, sysID);\n        ref1 = doc.children;\n        // Replace DTD if exists\n        for (i = j = 0, len = ref1.length; j < len; i = ++j) {\n          child = ref1[i];\n          if (child.type === NodeType.DocType) {\n            doc.children[i] = doctype;\n            return doctype;\n          }\n        }\n        ref2 = doc.children;\n        // insert before root node if the root node exists\n        for (i = k = 0, len1 = ref2.length; k < len1; i = ++k) {\n          child = ref2[i];\n          if (child.isRoot) {\n            doc.children.splice(i, 0, doctype);\n            return doctype;\n          }\n        }\n        // otherwise append to end\n        doc.children.push(doctype);\n        return doctype;\n      }\n\n      // Gets the parent node\n      up() {\n        if (this.isRoot) {\n          throw new Error(\"The root node has no parent. Use doc() if you need to get the document object.\");\n        }\n        return this.parent;\n      }\n\n      // Gets the root node\n      root() {\n        var node;\n        node = this;\n        while (node) {\n          if (node.type === NodeType.Document) {\n            return node.rootObject;\n          } else if (node.isRoot) {\n            return node;\n          } else {\n            node = node.parent;\n          }\n        }\n      }\n\n      // Gets the node representing the XML document\n      document() {\n        var node;\n        node = this;\n        while (node) {\n          if (node.type === NodeType.Document) {\n            return node;\n          } else {\n            node = node.parent;\n          }\n        }\n      }\n\n      // Ends the document and converts string\n      end(options) {\n        return this.document().end(options);\n      }\n\n      // Gets the previous node\n      prev() {\n        var i;\n        i = this.parent.children.indexOf(this);\n        if (i < 1) {\n          throw new Error(\"Already at the first node. \" + this.debugInfo());\n        }\n        return this.parent.children[i - 1];\n      }\n\n      // Gets the next node\n      next() {\n        var i;\n        i = this.parent.children.indexOf(this);\n        if (i === -1 || i === this.parent.children.length - 1) {\n          throw new Error(\"Already at the last node. \" + this.debugInfo());\n        }\n        return this.parent.children[i + 1];\n      }\n\n      // Imports cloned root from another XML document\n\n      // `doc` the XML document to insert nodes from\n      importDocument(doc) {\n        var child, clonedRoot, j, len, ref1;\n        clonedRoot = doc.root().clone();\n        clonedRoot.parent = this;\n        clonedRoot.isRoot = false;\n        this.children.push(clonedRoot);\n        // set properties if imported element becomes the root node\n        if (this.type === NodeType.Document) {\n          clonedRoot.isRoot = true;\n          clonedRoot.documentObject = this;\n          this.rootObject = clonedRoot;\n          // set dtd name\n          if (this.children) {\n            ref1 = this.children;\n            for (j = 0, len = ref1.length; j < len; j++) {\n              child = ref1[j];\n              if (child.type === NodeType.DocType) {\n                child.name = clonedRoot.name;\n                break;\n              }\n            }\n          }\n        }\n        return this;\n      }\n\n      \n      // Returns debug string for this node\n      debugInfo(name) {\n        var ref1, ref2;\n        name = name || this.name;\n        if ((name == null) && !((ref1 = this.parent) != null ? ref1.name : void 0)) {\n          return \"\";\n        } else if (name == null) {\n          return \"parent: <\" + this.parent.name + \">\";\n        } else if (!((ref2 = this.parent) != null ? ref2.name : void 0)) {\n          return \"node: <\" + name + \">\";\n        } else {\n          return \"node: <\" + name + \">, parent: <\" + this.parent.name + \">\";\n        }\n      }\n\n      // Aliases\n      ele(name, attributes, text) {\n        return this.element(name, attributes, text);\n      }\n\n      nod(name, attributes, text) {\n        return this.node(name, attributes, text);\n      }\n\n      txt(value) {\n        return this.text(value);\n      }\n\n      dat(value) {\n        return this.cdata(value);\n      }\n\n      com(value) {\n        return this.comment(value);\n      }\n\n      ins(target, value) {\n        return this.instruction(target, value);\n      }\n\n      doc() {\n        return this.document();\n      }\n\n      dec(version, encoding, standalone) {\n        return this.declaration(version, encoding, standalone);\n      }\n\n      e(name, attributes, text) {\n        return this.element(name, attributes, text);\n      }\n\n      n(name, attributes, text) {\n        return this.node(name, attributes, text);\n      }\n\n      t(value) {\n        return this.text(value);\n      }\n\n      d(value) {\n        return this.cdata(value);\n      }\n\n      c(value) {\n        return this.comment(value);\n      }\n\n      r(value) {\n        return this.raw(value);\n      }\n\n      i(target, value) {\n        return this.instruction(target, value);\n      }\n\n      u() {\n        return this.up();\n      }\n\n      // can be deprecated in a future release\n      importXMLBuilder(doc) {\n        return this.importDocument(doc);\n      }\n\n      // Adds or modifies an attribute.\n\n      // `name` attribute name\n      // `value` attribute value\n      attribute(name, value) {\n        throw new Error(\"attribute() applies to element nodes only.\");\n      }\n\n      att(name, value) {\n        return this.attribute(name, value);\n      }\n\n      a(name, value) {\n        return this.attribute(name, value);\n      }\n\n      // Removes an attribute\n\n      // `name` attribute name\n      removeAttribute(name) {\n        throw new Error(\"attribute() applies to element nodes only.\");\n      }\n\n      // DOM level 1 functions to be implemented later\n      replaceChild(newChild, oldChild) {\n        throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n      }\n\n      removeChild(oldChild) {\n        throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n      }\n\n      appendChild(newChild) {\n        throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n      }\n\n      hasChildNodes() {\n        return this.children.length !== 0;\n      }\n\n      cloneNode(deep) {\n        throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n      }\n\n      normalize() {\n        throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n      }\n\n      // DOM level 2\n      isSupported(feature, version) {\n        return true;\n      }\n\n      hasAttributes() {\n        return this.attribs.length !== 0;\n      }\n\n      // DOM level 3 functions to be implemented later\n      compareDocumentPosition(other) {\n        var ref, res;\n        ref = this;\n        if (ref === other) {\n          return 0;\n        } else if (this.document() !== other.document()) {\n          res = DocumentPosition.Disconnected | DocumentPosition.ImplementationSpecific;\n          if (Math.random() < 0.5) {\n            res |= DocumentPosition.Preceding;\n          } else {\n            res |= DocumentPosition.Following;\n          }\n          return res;\n        } else if (ref.isAncestor(other)) {\n          return DocumentPosition.Contains | DocumentPosition.Preceding;\n        } else if (ref.isDescendant(other)) {\n          return DocumentPosition.Contains | DocumentPosition.Following;\n        } else if (ref.isPreceding(other)) {\n          return DocumentPosition.Preceding;\n        } else {\n          return DocumentPosition.Following;\n        }\n      }\n\n      isSameNode(other) {\n        throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n      }\n\n      lookupPrefix(namespaceURI) {\n        throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n      }\n\n      isDefaultNamespace(namespaceURI) {\n        throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n      }\n\n      lookupNamespaceURI(prefix) {\n        throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n      }\n\n      isEqualNode(node) {\n        var i, j, ref1;\n        if (node.nodeType !== this.nodeType) {\n          return false;\n        }\n        if (node.children.length !== this.children.length) {\n          return false;\n        }\n        for (i = j = 0, ref1 = this.children.length - 1; (0 <= ref1 ? j <= ref1 : j >= ref1); i = 0 <= ref1 ? ++j : --j) {\n          if (!this.children[i].isEqualNode(node.children[i])) {\n            return false;\n          }\n        }\n        return true;\n      }\n\n      getFeature(feature, version) {\n        throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n      }\n\n      setUserData(key, data, handler) {\n        throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n      }\n\n      getUserData(key) {\n        throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n      }\n\n      // Returns true if other is an inclusive descendant of node,\n      // and false otherwise.\n      contains(other) {\n        if (!other) {\n          return false;\n        }\n        return other === this || this.isDescendant(other);\n      }\n\n      // An object A is called a descendant of an object B, if either A is \n      // a child of B or A is a child of an object C that is a descendant of B.\n      isDescendant(node) {\n        var child, isDescendantChild, j, len, ref1;\n        ref1 = this.children;\n        for (j = 0, len = ref1.length; j < len; j++) {\n          child = ref1[j];\n          if (node === child) {\n            return true;\n          }\n          isDescendantChild = child.isDescendant(node);\n          if (isDescendantChild) {\n            return true;\n          }\n        }\n        return false;\n      }\n\n      // An object A is called an ancestor of an object B if and only if\n      // B is a descendant of A.\n      isAncestor(node) {\n        return node.isDescendant(this);\n      }\n\n      // An object A is preceding an object B if A and B are in the \n      // same tree and A comes before B in tree order.\n      isPreceding(node) {\n        var nodePos, thisPos;\n        nodePos = this.treePosition(node);\n        thisPos = this.treePosition(this);\n        if (nodePos === -1 || thisPos === -1) {\n          return false;\n        } else {\n          return nodePos < thisPos;\n        }\n      }\n\n      // An object A is folllowing an object B if A and B are in the \n      // same tree and A comes after B in tree order.\n      isFollowing(node) {\n        var nodePos, thisPos;\n        nodePos = this.treePosition(node);\n        thisPos = this.treePosition(this);\n        if (nodePos === -1 || thisPos === -1) {\n          return false;\n        } else {\n          return nodePos > thisPos;\n        }\n      }\n\n      // Returns the preorder position of the given node in the tree, or -1\n      // if the node is not in the tree.\n      treePosition(node) {\n        var found, pos;\n        pos = 0;\n        found = false;\n        this.foreachTreeNode(this.document(), function(childNode) {\n          pos++;\n          if (!found && childNode === node) {\n            return found = true;\n          }\n        });\n        if (found) {\n          return pos;\n        } else {\n          return -1;\n        }\n      }\n\n      \n      // Depth-first preorder traversal through the XML tree\n      foreachTreeNode(node, func) {\n        var child, j, len, ref1, res;\n        node || (node = this.document());\n        ref1 = node.children;\n        for (j = 0, len = ref1.length; j < len; j++) {\n          child = ref1[j];\n          if (res = func(child)) {\n            return res;\n          } else {\n            res = this.foreachTreeNode(child, func);\n            if (res) {\n              return res;\n            }\n          }\n        }\n      }\n\n    };\n\n    // DOM level 1\n    Object.defineProperty(XMLNode.prototype, 'nodeName', {\n      get: function() {\n        return this.name;\n      }\n    });\n\n    Object.defineProperty(XMLNode.prototype, 'nodeType', {\n      get: function() {\n        return this.type;\n      }\n    });\n\n    Object.defineProperty(XMLNode.prototype, 'nodeValue', {\n      get: function() {\n        return this.value;\n      }\n    });\n\n    Object.defineProperty(XMLNode.prototype, 'parentNode', {\n      get: function() {\n        return this.parent;\n      }\n    });\n\n    Object.defineProperty(XMLNode.prototype, 'childNodes', {\n      get: function() {\n        if (!this.childNodeList || !this.childNodeList.nodes) {\n          this.childNodeList = new XMLNodeList(this.children);\n        }\n        return this.childNodeList;\n      }\n    });\n\n    Object.defineProperty(XMLNode.prototype, 'firstChild', {\n      get: function() {\n        return this.children[0] || null;\n      }\n    });\n\n    Object.defineProperty(XMLNode.prototype, 'lastChild', {\n      get: function() {\n        return this.children[this.children.length - 1] || null;\n      }\n    });\n\n    Object.defineProperty(XMLNode.prototype, 'previousSibling', {\n      get: function() {\n        var i;\n        i = this.parent.children.indexOf(this);\n        return this.parent.children[i - 1] || null;\n      }\n    });\n\n    Object.defineProperty(XMLNode.prototype, 'nextSibling', {\n      get: function() {\n        var i;\n        i = this.parent.children.indexOf(this);\n        return this.parent.children[i + 1] || null;\n      }\n    });\n\n    Object.defineProperty(XMLNode.prototype, 'ownerDocument', {\n      get: function() {\n        return this.document() || null;\n      }\n    });\n\n    // DOM level 3\n    Object.defineProperty(XMLNode.prototype, 'textContent', {\n      get: function() {\n        var child, j, len, ref1, str;\n        if (this.nodeType === NodeType.Element || this.nodeType === NodeType.DocumentFragment) {\n          str = '';\n          ref1 = this.children;\n          for (j = 0, len = ref1.length; j < len; j++) {\n            child = ref1[j];\n            if (child.textContent) {\n              str += child.textContent;\n            }\n          }\n          return str;\n        } else {\n          return null;\n        }\n      },\n      set: function(value) {\n        throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n      }\n    });\n\n    return XMLNode;\n\n  }).call(this);\n\n}).call(this);\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}